<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/vs.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 1 | Lesson 3</i>
			<h1>Kotlin Programming Basics</h1>
			<em>Objects, Classes, Functions and Methods, Access modifiers</em>
			<em>Anonymous Function & Lambda Expression</em><br />
			<em>Extension Functions</em><br />
			<em>Scope Functions</em><br />
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Functions</h2>
			</section>
			<section>
				<h3>Function</h3>
				<div class="summary">
					Kotlin is a modern language, supporting both traditional functions and object-oriented programming
					and functional programming paradigms.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<br />
							Functions are defined using the <code class="hljs inline">fun</code> keyword,
							followed by the function name, arguments, and return type.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun add(a: Int, b: Int): Int {
										return a + b
									}

									val sum = add(2, 3)
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<br />
							If the function does not return anything, the return type is <code class="hljs inline">Unit</code>,
							and does not need to be specified explicitly.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun greet(name: String) {
										println("Hello, $name!")
									}

									greet("Alice")
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<br />
							Functions can be written in a single expression, in which case the return type can be omitted.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun add(a: Int, b: Int) = a + b
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<br />
							Functions can be passed as arguments to other functions and returned from functions.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun operation(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
										return operation(a, b)
									}

									val sum = operation(2, 3) { a, b -> a + b }
								</code>
							</pre>
						</div>
					</div>
					<blockquote>
						Functions can be defined at the top level of a file, meaning they do not need to be part of a class.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Local functions</h3>
				<div class="summary">
					Functions can be defined inside other functions, in which case they are called local functions.
				</div>
				<div class="content">
					Defining a local functions is useful when you want to encapsulate some logic that is used multiple times
					but only within the function in which it is defined.
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							// outer function
							fun factorial(n: Int): Int {

								// local function
								fun fact(x: Int, acc: Int): Int {
									return if (x <= 1) acc else fact(x - 1, x * acc) // tail recursion
								}

								// calls the local function
								return fact(n, 1)
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							// main entry point with a call to the outer function
							fun main() {
								println(factorial(5)) // prints 120
							}
						</code>
					</pre>
				</div>
			</section>

			<section>
				<h3>Default arguments</h3>
				<div class="summary">
					Kotlin allows you to specify default values for function arguments, making them optional.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun round(
										value: Double,
										decimals: Int = 2 // argument with default value od 2
									): Double {
										val factor = 10.0.pow(decimals.toDouble())
										return (value * factor).roundToInt() / factor
									}
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Given a function with a default argument ...
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(3.14159)

									println(result) // prints 3.14
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							When the argument is not provided when calling the function, the default value is used.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(3.14159, 4)

									println(result) // prints 3.1416
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							When the argument is provided when calling the function, the provided value is used.
						</div>
					</div>
				</div>
			</section>

			<section>
				<h3>Named arguments</h3>
				<div class="summary">
					Kotlin allows you to specify the name of the arguments when calling a function.
				</div>
				<div class="content">
					<p>
						This is useful when you have a function with many arguments, and you want to make the code more readable,
						for example when you have a function with many arguments.
					</p>
					<p>
						It also allows you to specify arguments in any order, as long as you specify the name.
						This ofthe comes in handy when refactoring the code, adding or changing order of arguments.
					</p>

					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun round(
										value: Double,
										decimals: Int = 2
									): Double {
										val factor = 10.0.pow(decimals.toDouble())
										return (value * factor).roundToInt() / factor
									}
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Given function ...
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(value = 3.14159)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							You may specify the argument name.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(
										decimals = 4, // notice the changed order of arguments
										value = 3.14159
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							You may specify the argument names in any order.
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Named arguments</h3>
				<div class="content">
					A bigger example of using named arguments:
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun calculateEvapotranspiration(
										temperature: Double,
										solarRadiation: Double,
										humidity: Double,
										windSpeed: Double,
										atmosphericPressure: Double,
										location: Pair&lt;Double, Double&gt;,
										time: LocalDateTime,
										soilType: SoilType,
										cropType: CropType
									): Double {
										// calculation
									}
								</code>
							</pre>
					</div>
						<div class="column">
							Without argument names ...
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									calculateEvapotranspiration(
										25.0,
										800.0,
										0.6,
										3.0,
										1013.25,
										13.7655756 to 100.5675686,
										LocalDateTime.now(),
										SoilType.CLAY,
										CropType.WHEAT,
									)
								</code>
							</pre>
							With argument names ...
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									calculateEvapotranspiration(
										soilType = SoilType.CLAY,
										cropType = CropType.WHEAT,
										time = LocalDateTime.now(),
										location = 13.7655756 to 100.5675686,
										temperature = 25.0,
										solarRadiation = 800.0,
										humidity = 0.6,
										windSpeed = 3.0,
										atmosphericPressure = 1013.25
									)
								</code>
							</pre>
						</div>
				</div>

			</section>
			<section>
				<h3>Variable Arguments</h3>
				<div class="summary">
					Variadic functions are functions that can take a variable number of arguments.
				</div>
				<div class="content">
					<p>
						You can define a function that takes a variable number of arguments by using the <code class="inline">vararg</code> keyword.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun sayHello(vararg names: String): Int {
								println("Hello, ${names.joinToString(", ")}!")
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun main() {
								sayHello("Alice", "Bob", "Charlie") // prints "Hello, Alice, Bob, Charlie!"
							}
						</code>
					</pre>
					<p>
						If you need more than one argument, the <code class="inline">vararg</code> argument must be the last one.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun sayHello(greeting: String, vararg numbers: Int): Int {
								println("Hello, ${names.joinToString(", ")}!")
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun main() {
								sayHello(greeting = "Hi", "Alice", "Bob", "Charlie") // prints "Hi, Alice, Bob, Charlie!"
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Objects and Classes</h2>
			</section>
			<section>
				<h3>Objects and Classes</h3>
				<div class="summary">
					We have already seen and worked with Kotlin objects and classes.
					<br />
					Let's explain what they are and how they work in more detail.
				</div>
				<div class="content content-center">
					<br />
					<div>
						<div class="highlight" style="font-size: larger; font-weight: bolder">What is an object?</div><br />
						<div style="font-size: larger; font-style: italic" class="fragment fade-in">Object is a data structure in memory<br /></div>
					</div>
					<br />
					<br />
					<div>
						<div class="highlight" style="font-size: larger; font-weight: bolder">What is a class?</div><br />
						<div style="font-size: larger; font-style: italic" class="fragment fade-in">Class is a template for how to create an object</div>
					</div>
					<br />
					<blockquote class="fragment fade-in">
						Think of a class as a blueprint for creating objects.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Class Definition</h3>
				<div class="summary">
					Class is defined using the <code class="hljs inline">class</code> keyword, followed by the class name,
					class header and the class body.
				</div>
				<div class="content">
					<ul>
					<li>
						<span class="highlight">Class name</span> -
						should begin with an initial letter (capitalized by convention).
					</li>
					<li>
						<span class="highlight">Class header</span> -
						class type parameters, the primary constructor, and other things, such as its superclass or interfaces it implements.
					</li>
					<li>
						<span class="highlight">Class properties</span> -
						are defined in the class header and are used to hold the state of the class and its objects.
					</li>
					<li>
						<span class="highlight">Class body</span> -
						containing fields, methods, constructors, initializer blocks, inner classes, and interfaces enclosed in curly braces.
						<ul>
							<li>
								<span class="highlight">Fields</span> -
								additional properties that hold the state of the class and its objects.
							</li>
							<li>
								<span class="highlight">Methods</span> -
								functions that are part of the class and contain the executable code.
							</li>
							<li>
								<span class="highlight">Constructors</span> -
								special methods used to initialize the state of an object.
							</li>
							<li>
								<span class="highlight">Initializer blocks</span> -
								unnamed code blocks used for initializing shared variables and executing code that needs to run every time an instance of the class is created.
							</li>
							<li>
								<span class="highlight">Inner classes and interfaces</span> -
								class or interface definitions nested within the outer class body.
							</li>
							<li>
								<span class="highlight">Companion objects</span> -
								special objects that are tied to a class, rather than to an instance of a class.
							</li>
						</ul>
					</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Class Definition</h3>
				<div class="summary">
					Class is defined using the <code class="hljs inline">class</code> keyword, followed by the class name,
					class header (optional), and the class body (optional) enclosed in curly braces.
				</div>
				<div class="content">
					<div>
						Simple class definition without body.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								class UniversityCourse
							</code>
						</pre>
					</div>
					<div>
						More realistic class definition with parameters and body.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								class UniversityCourse(
									val subject: String,
									val startDate: LocalDate,
									val endDate: LocalDate,
									val students: MutableList&lt;String&gt; = mutableListOf() // initial value of empty list
								) {

									// class field which is not part of the constructor
									private var isOpen: Boolean = false // initial value of false

									fun addStudent(studentName: String) {
										if (isOpen) {
											students.add(studentName)
										} else {
											error("Cannot add students to closed course.")
										}
									}

									fun open() {
										isOpen = true
									}

									fun close() {
										isOpen = false
									}
								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h3>Class Instantiation</h3>
				<div class="summary">
					You do not directly work with classes in Kotlin, you work with objects that are created from classes, called class instances.
				</div>
				<blockquote>
					Object == Instance of a class
				</blockquote>
				<div class="content">
					<ul>
						<li>The process that creates an object from class is called <strong>instantiation</strong></li>
						<li>Instantiation is done by calling a special <strong>constructor</strong> method</li>
						<li>Class may have <strong>one or more</strong> constructors</li>
						<li>If constructor is not explicitly defined, then the class will <strong>default constructor with no arguments</strong></li>
						<li>Instantiation can be used to set initial values for the object</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Class Header</h3>
				<div class="summary">
					Class header defines its type parameters, the primary constructor, and other things,
					such it's superclass or interfaces it implements.
				</div>
				<div class="content">
					<div>
						<ul>
							<li>The class header specifies class properties (fields).</li>
							<li>Just like functions argument, class fields can have default values.</li>
							<li>The declared fields also define the class primary constructor.</li>
							<li>
								In this example, the class header specifies that the class has four fields, one with a default value,
								which means that it can be omitted when creating an instance of the class.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class UniversityCourse(
											val subject: String,
											val startDate: LocalDate,
											val endDate: LocalDate,
											val students: MutableList&lt;String&gt; = mutableListOf() // initial value of empty list
										) {
											// class body
										}
									</code>
								</pre>
							</li>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<h3>Class Constructors</h3>
				<div class="summary">
					Class constructor is a special method with the only purpose of class instantiation.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							Class with zero arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class KotlinCourse {
										val subject: String = "Kotlin"
									}


									val kotlinCourse = KotlinCourse()
								</code>
							</pre>
							Class with one arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class Course(val subject: String)


									val kotlinCourse = Course("Kotlin")
								</code>
							</pre>
						</div>
						<div class="column">
							Class with multiple arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class Course(
										val subject: String,
										val startDate: LocalDate,
										val endDate: LocalDate
									)


									val kotlinCourse = Course(
										"Kotlin",
										LocalDate.parse("2024-02-03"),
										LocalDate.parse("2024-02-21")
									)
								</code>
							</pre>
						</div>
					</div>
					<ul>
						<li>Every class has a constructor, even if it is not explicitly defined.</li>
						<li>Class may have multiple constructors (primary and secondary constructors).</li>
						<li>Constructor may have zero, one, or many arguments</li>
						<li>Class constructors support named arguments just like functions.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Alternate class constructors</h3>
				<div class="summary">
					Kotlin allows you to define multiple constructors for a class, also called secondary constructors.
					They provide alternative ways to instantiate the class.
				</div>
				<div class="content">
				Example of class definition, class alternate constructor, and constructor calls.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							// primary constructor defined by class header
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate
							) {

								// alternate constructor
								constructor(
									subject: String,
									startDate: String,
									endDate: String,
								) : this(subject, LocalDate.parse(startDate), LocalDate.parse(endDate))
							}
						</code>
					</pre>
					Primary constructor call with default values
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse1 = UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"), LocalDate.parse("2024-02-21"))
						</code>
					</pre>
					Alternate constructor call
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse3 = UniversityCourse("Kotlin", "2024-02-03", "2024-02-21")
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Default values & Named arguments</h3>
				<div class="summary">
					Just like functions, class constructors can have default values and support named arguments.
				</div>
				<div class="content">
					Class constructor really is just a special kind of function, so just like functions,
					class constructors can have default values and support named arguments.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),    // default date
								val students: MutableList&lt;String&gt; = mutableListOf() // default value of empty list
							) {
								// class body
							}
						</code>
					</pre>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"))
								</code>
							</pre>
						</div>
						<div class="column"><br />Calling the constructor with default values.</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse(
										"Kotlin",
										LocalDate.parse("2024-02-03"),
										students = mutableListOf("Alice", "Bob")
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Calling the constructor with one named argument for <strong>students</strong>.
							<br />
							The <strong>endDate</strong> will be set to the default value.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse(
										subject = "Kotlin",
										startDate = LocalDate.parse("2024-02-03"),
										endDate = LocalDate.parse("2024-02-21"),
										students = mutableListOf("Alice", "Bob")
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Naming all arguments when calling the constructor.
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Methods</h3>
				<div class="summary">
					Method is a function associated with an object.<br />
					In Kotlin, you can also call methods member functions.
				</div>
				<div class="content">
					<p>
						Same rules and possibilities apply to methods as to functions not associated with a class.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							) {

								fun addStudent(studentName: String) {
									students.add(studentName)
								}

								fun removeStudent(studentName: String) {
									students.remove(studentName)
								}

								fun printStudents() {
									students.forEach { println(it) }
								}
							}
						</code>
					</pre>
					<p>
						The only difference is that methods are called on an instance of object.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse = UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"))
							kotlinCourse.addStudent("Alice")
							kotlinCourse.addStudent("Bob")
							kotlinCourse.printStudents()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Initializer blocks</h3>
				<div class="summary">
					Initializer blocks are code that is run when an instance of a class is created.
				</div>
				<div class="content">
					<p>
						For example, this can be used for additional argument validation or to set up some initial state.
					</p>
					<p>
						Class may have one or more initializer blocks, which are executed in the order they are defined.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							) {

								init {
									require(startDate < endDate) { "End date must be after start date" }
								}

								init {
									println("Course $subject created")
								}

							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Scope and "this" reference</h3>
				<div class="summary">
					In Kotlin, the <code class="inline">this</code> keyword is used to refer to the current instance of a class.
				</div>
				<div class="content">
					It is often used to distinguish between class properties and parameters or local variables with the same name.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class Person(val name: String) {

								fun introduce(name: String) {
									println("${this.name} also goes by $name")
								}

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val person = Person("Monika")
								person.introduce("Moni") // prints "Monika also goes by Moni"
							}
						</code>
					</pre>
					Additionally, Kotlin provides other scope references using <code class="inline">@label</code> to refer to specific instances in nested scopes.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class A {
								inner class B {
									fun Int.foo() {
										val a = this@A // refers to the instance of A
										val b = this@B // refers to the instance of B
										val c = this // refers to the receiver Int
										println("a: $a, b: $b, c: $c")
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val a = A()
								val b = a.B()
								b.run { 42.foo() }
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Class destruction</h3>
				<div class="summary">
						Java/Kotlin has no class destructor, because freeing up memory is entirely delegated to JVM through
						a process called <strong>garbage collection</strong>, which we will talk about in later in the course.
				</div>
				<div class="content">
					Some Java/Kotlin classes may have a special methods that should be called after we are done using
					the class in order for it to be eligible for garbage collection. I will also mention these
					later in the course.
				</div>
			</section>
			<section>
				<h3>Inner classes</h3>
				<div class="summary">
					Inner class (also called nested class), is a class defined within a body of another class.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class OuterClass {

								private val outerField: String = "Outer Field"

								// Inner class
								inner class InnerClass {
									fun accessOuterField(): String {
										return outerField
									}
								}
							}
							</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val outer = OuterClass()
								val inner = outer.InnerClass()
								println(inner.accessOuterField()) // prints "Outer Field"
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Use case for nested classes</h3>
				<div class="content">
					<br />
					<h4>Logical Grouping</h4>
					<div>
						Nested classes can help us keep our code organized by having related code together.
						For example, you may want to create an internal data class.
					</div>
					<br />
					<br />
<!--						</li>-->
						<!--					<li>-->
						<!--						<strong>Access Control</strong>-->
						<!--						<div>-->
						<!--							Inner classes can access members of the outer class, including those marked as private.-->
						<!--							This feature is helpful when you need to create a helper class that needs access to an outer-->
						<!--							classâ€™s fields or methods.-->
						<!--						</div>-->
						<!--					</li>-->
<!--						<li>-->
					<h4>Encapsulation & Access Control</h4>
					<div>
						Inner classes can access members of the outer class, including those marked as private.
						This can benefit us in multiple scenarios, such us when creating helper classes without exposing
						private methods or fields of the outer class.
						<!--							Consider two top-level classes, A and B, where B needs access to the private members of A.-->
						<!--							We could change the visibility of A's members from private to protected or public to allow B access.-->
						<!--							However, this would also provide access to all other classes which is sometimes not desirable.-->
					</div>
					<br />
					<br />
					<h4>Increased Readability and Maintainability</h4>
					<div>
						Inner classes are used for code that is relevant to a small part of the outer class.
						Grouping them together improves code readability and maintainability.
					</div>
				</div>
			</section>
			<section>
				<h3>Anonymous Classes</h3>
				<div class="summary">
<!--					Anonymous class is a class which does not have a name.-->
					In Kotlin, anonymous classes are a way to create an instance of a class with certain modifications
					without having to actually declare a new subclass. They are often used to create instances
					of classes that have no name and are used only once.
				</div>
<!--				<p>-->
<!--					In Java, an anonymous class is an inner class (a class within another class), which does not have a name.-->
<!--					Since it has no name, we have no way to instantiate such class. Thus, an anonymous class must be declared and instantiated with a single expression.-->
<!--				</p>-->
				<div class="content">
					<p>
						Since it has no name, we have no way to instantiate such class.<br />
						Thus, an anonymous class must be declared and instantiated with a single expression.
					</p>
					<p>
						An anonymous class must either implement an interface or extend an existing class (abstract or concrete).
					</p>
					<p>
<!--						Anonymous classes are helpful when we wish to use a local class only once, but their use is-->
<!--						generally discouraged in favour of Lambda expression (which I'll explain shortly).-->
						Anonymous classes are useful for creating quick, one-off implementations of interfaces or abstract classes.
					</p>
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						fun main() {

							val runnable = object : Runnable {
								override fun run() {
									println("Running in an anonymous class!")
								}
							}

							val thread = Thread(runnable)

							thread.start()
						}
					</code>
				</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Singleton Objects</h2>
				<em>Static classes and constants in Kotlin</em>
			</section>
			<section>
				<h3>Singleton Objects</h3>
				<div class="summary">
					Singleton object is a class that can have only one instance in memory.
				</div>
				<div class="content">
					<p>
						In Java and other languages, we used so called singleton pattern to create a class that can have only one instance.
					</p>
					<p>
						Kotlin provides a convenient way to create singleton objects using the <code class="inline">object</code> keyword.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							object StringUtils {

								val DECIMAL_PLACES = 2

								fun formatNumber(number: Double): String {
									// code to format number
								}

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val formattedNumber = StringUtils.formatNumber(3.14159)
								println(formattedNumber) // prints "3.14"
							}
						</code>
					</pre>
					<h4>Some key features:</h4>
					<ul>
						<li><strong>Singleton</strong> - Only one instance of the object is created.</li>
						<li><strong>Utility Methods</strong> - Commonly used for utility methods and constants.</li>
						<li><strong>Initialization</strong> - The object is initialized when it is first accessed.</li>
						<li><strong>No Constructors</strong> - Objects cannot have constructors.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Use case for static objects</h3>
				<div class="content">
					<h4>Utility or Helper Classes</h4>
					<p>
						Sometimes we need some methods to be globally available in the application without needing to create class instance every time.
						Example of such is utility classs with static methods is <code class="inline">String.valueOf()</code>
						or <code class="inline">Integer.toBinaryString()</code>.
					</p>
					<br />
					<h4>Global Constants and Variables</h4>
					<p>
						Static keyword can be used to define class level variables hat are accessible throughout our application.
					</p>
					<br />
					<h4>Singleton Pattern</h4>
					<p>
						Kotlin object is equivalent to Java's singleton pattern, but with the convenience of a simpler, error-proof syntax.
						Singleton class is a design pattern that restricts the instantiation of a class to a single instance.
					</p>
				</div>
			</section>
			<section>
				<h3>Companion Objects</h3>
				<div class="summary">
					Companion object is an object that is tied to a class, rather than to an instance of a class.
				</div>
				<div class="content">
					<ul>
						<li>There can be only one companion object per class, and it is defined using the <code class="inline">companion</code> keyword.</li>
						<li>It may have a name, but it is optional. Otherwise, it is referred to as a default companion object.</li>
						<li>It is often used to define static methods and constants.</li>
						<li>Other than that, it is just like any other object.</li>
						<li>Companion objects are by convention placed at the bottom of the class.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate
							) {

								// regular class methods

								companion object UniversityCourseFactory { // companion object name is optional
									const val KOTLIN = "Kotlin"

									fun kotlinCourse(startDate: String, endDate: String): UniversityCourse {
										return UniversityCourse(KOTLIN, LocalDate.parse(startDate), LocalDate.parse(endDate))
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {

								val kotlinCourse = UniversityCourse.kotlinCourse("2024-02-03", "2024-02-21")

								println(UniversityCourse.KOTLIN) // prints "Kotlin"

							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Packages, Imports and Modifiers</h2>
			</section>
			<section>
				<h3>Packages</h3>
				<div class="summary">
					Packages are used to organize code into namespaces, making it easier to manage and avoid naming conflicts.
					<!--					Packages are a way of organizing code. They are basically directories.-->
				</div>
				<div class="content">
					<ul>
						<li>The package declaration is usually the first line in a Kotlin file. It specifies the package to which the file belongs.</li>
						<li>Package names are typically written in all lowercase and follow the reverse domain name convention.</li>
						<li>To use classes and functions from other packages, you need to <code class="inline">import</code> them using the import keyword.</li>
						<li>If no package is specified, the file belongs to the default package.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package com.motycka.edu.model // <- package name

							import java.time.LocalDate // <- import of class LocalDate from java.time package

							class User(
								val name: String,
								val birthDate: LocalDate
							)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Modifiers</h3>
				<div class="summary">
					Modifiers in programming languages are keywords that you can use to change the properties or behavior of classes, methods, and variables.
				</div>
				<div class="content">
					<p>
						They can be broadly categorized into two types:
					</p>
					<br />
					<h4>Access Modifiers</h4>
					<p>
						These define the visibility or accessibility of functions, classes, methods, and variables.
					</p>
					<br />
					<h4>Non-Access Modifiers</h4>
					<p>
						These define other characteristics such as behavior, state, or implementation details.
					</p>
				</div>
			</section>
			<section>
				<h3>Access Modifiers</h3>
				<div class="summary">
					Access, modifiers define the visibility or accessibility of functions, classes, methods, and variables.
				</div>
				<div class="content">
					<table>
						<thead>
						<tr>
							<td><strong>modifier</strong></td>
							<td><strong>on class</strong></td>
							<td><strong>on method</strong></td>
							<td><strong>on field</strong></td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td><strong><code class="inline">public</code></strong></td>
							<td>accessible from anywhere</td>
							<td>accessible from anywhere</td>
							<td>accessible from anywhere</td>
						</tr>
						<tr>
							<td><strong><code class="inline">private</code></strong></td>
							<td>only accessible within the same package</td>
							<td>only accessible within same class</td>
							<td>only accessible within same class</td>
						</tr>
						<tr>
							<td><strong><code class="inline">protected</code></strong></td>
							<td>accessible within the same package</td>
							<td>only accessible within same class or it's subclass</td>
							<td>only accessible within same class or it's subclass</td>
						</tr>
						<tr>
							<td><strong><code class="inline">internal</code></strong></td>
							<td>accessible within the same module</td>
							<td>accessible within the same module</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><span style="font-style: italic">default</span></td>
							<td>same as public</td>
							<td>same as public</td>
							<td>same as public</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Non-Access Modifiers</h3>
				<div class="summary">
					Non-access modifiers define other characteristics such as behavior, state, or implementation details.
				</div>
				<div class="content" style="font-size: 70%">
					<table>
						<thead>
						<tr>
							<td><strong>modifier</strong></td>
							<td><strong>on class</strong></td>
							<td><strong>on method / block</strong></td>
							<td><strong>on field</strong></td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td><code class="inline">abstract</code></td>
							<td>Class marked as abstract cannot be directly instantiated.</td>
							<td>Method marked as abstract does not provide implementation, but expects a <em>subclass</em> to implement it.</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><code class="inline">final</code></td>
							<td>prevents inheritance</td>
							<td>prevents method overloading</td>
							<td>Makes variable a constant = value cannot be changed after initialization.</td>
						</tr>
						<tr>
							<td><code class="inline">open</code></td>
							<td>Allows class to be inherited</td>
							<td>Allows method to be overridden</td>
							<td>Allows property to be changed</td>
						</tr>
						<tr>
							<td><code class="inline">override</code></td>
							<td>N/A</td>
							<td>Indicates that a method is overriding a method in a superclass.</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><code class="inline">lateinit</code></td>
							<td>N/A</td>
							<td>Indicates that a property will be initialized later.</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><code class="inline">const</code></td>
							<td>N/A</td>
							<td>N/A</td>
							<td>Indicates that a property is a compile-time constant.</td>
						</tr>
						<tr>
							<td><code class="inline">companion</code></td>
							<td>N/A</td>
							<td>N/A</td>
							<td>Defines a companion object, which is an object that is tied to a class and can access its private members.</td>
						</tr>
<!--						<tr>-->
<!--							<td><strong><code>static</code></strong></td>-->
<!--							<td>N/A</td>-->
<!--							<td>accessible without need to create class instance</td>-->
<!--							<td>Make variable global, also called <em>class variable</em>, as opposed to <em>instance variable</em>.</td>-->
<!--						</tr>-->
<!--						<tr>-->
<!--							<td><strong><code>synchronized</code></strong></td>-->
<!--							<td>N/A</td>-->
<!--							<td>Used to control access to an object by multiple threads. It is primarily used to prevent thread interference.</td>-->
<!--							<td>N/A</td>-->
<!--						</tr>-->
<!--						<tr>-->
<!--							<td><strong><code>volatile</code></strong></td>-->
<!--							<td>N/A</td>-->
<!--							<td>N/A</td>-->
<!--							<td>Used in multi-threaded environment, ensures that changes made in one thread are immediately reflect in another thread.</td>-->
<!--						</tr>-->
<!--						<tr>-->
<!--							<td><strong><code>native</code></strong></td>-->
<!--							<td>N/A</td>-->
<!--							<td>Used to declare a method that is implemented in native code using JNI (Java Native Interface).</td>-->
<!--							<td>N/A</td>-->
<!--						</tr>-->
<!--						<tr>-->
<!--							<td><strong><code>transient</code></strong></td>-->
<!--							<td>N/A</td>-->
<!--							<td>N/A</td>-->
<!--							<td>Used in object serialization, it indicates that a field should not be serialized.</td>-->
<!--						</tr>-->
						</tbody>
					</table>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Data Classes</h2>
			</section>
			<section>
				<h3>Data Classes</h3>
				<div class="summary">
					Data classes are a special type of class in Kotlin that are used to represent data.
				</div>
				<div class="content">
					<p>
					For a data class, Kotlin compiler automatically generates convenience methods for copying,
					comparing, and printing objects and more.
					</p>
					<p>
					Data classes are marked with the <code class="inline">data</code> keyword.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							)
						</code>
					</pre>
					<p>
						There are few rules for data classes:
					</p>
					<ul>
						<li>Primary constructor must have at least one parameter.</li>
						<li>Primary constructor must have <code class="inline">val</code> or <code class="inline">var</code> keyword.</li>
						<li>Data classes cannot be abstract, open, sealed, or inner.</li>
						<li>Data classes cannot inherit from other classes.</li>
					</ul>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Enums</h2>
			</section>
			<section>
				<h3>Enums</h3>
				<div class="summary">
					Enum (enumeration) is a special type of class, which contains a fixed set of constants.
				</div>
				<div class="content">
					<ul>
						<li>Enum is created with the <code class="inline">enum class</code> keyword.</li>
						<li>Enum constants are static and final implicitly.</li>
						<li>By convention, the enum values should be in upper case.</li>
						<li>enums can also have properties, methods, and can be initialized with a constructor.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							enum class Days {
								MONDAY,
								TUESDAY,
								WEDNESDAY,
								THURSDAY,
								FRIDAY,
								SATURDAY,
								SUNDAY
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val day = Days.MONDAY
								println(day) // prints "MONDAY"
							}
						</code>
					</pre>
				</div>
			</section>

			<section>
				<h3>Enums</h3>
				<div class="summary">
					Since enum is a class, it may have <em>fields</em>, <em>constructors</em> and <em>methods</em>.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							enum class Days(val isWorkDay: Boolean) {
								MONDAY(true),
								TUESDAY(true),
								WEDNESDAY(true),
								THURSDAY(true),
								FRIDAY(true),
								SATURDAY(false),
								SUNDAY(false);

								fun isWeekend(): Boolean {
									return !isWorkDay
								}

								fun isWeekday(): Boolean {
									return isWorkDay
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val day = Days.MONDAY
								println(day) // prints MONDAY
								println(day.isWorkDay()) // prints true
							}
						</code>
					</pre>
				</div>
			</section>

			<section>
				<h3>Enums</h3>
				<div class="summary">
					Enums are particularly useful for evaluating a finite number of states.
				</div>
				<div class="content">
					<p>
						Especially in combination with <code class="inline">when</code> expression.
					</p>
					<p>
						Whenever you use <code class="inline">when</code> with enums, the compiler will check if all possible values are covered.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun getHoursInClass(day: Days): Int {
								return when (day) {
									Days.MONDAY,
									Days.TUESDAY,
									Days.THURSDAY -> 4
									Days.WEDNESDAY,
									Days.FRIDAY -> 3
									Days.SATURDAY,
									Days.SUNDAY -> 0
								}
							}
						</code>
					</pre>
					<p>
						In case you forget to cover all possible values, the compiler will throw an error.
						You may also use <code class="inline">else</code> branch to cover all other cases.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun getHoursInClass(day: Days): Int {
								return when (day) {
									Days.MONDAY,
									Days.TUESDAY,
									Days.THURSDAY -> 4
									Days.WEDNESDAY,
									Days.FRIDAY -> 3
									else -> 0
								}
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Anonymous Function & Lambda Expression</h2>
			</section>
			<section>
				<h3>Anonymous Function & Lambda Expression</h3>
				<div class="summary">
					Anonymous functions and lambda expressions are used to define functions without names.
				</div>
				<div class="content">
					<h4>Lambda Expression</h4>
					<p>
						Lambda expressions are typically used for short, concise functions that are passed as arguments to higher-order functions.
						They are commonly used in collection operations like <code class="inline"></code>, <code class="inline">filter</code>, and <code class="inline">forEach</code>.
					</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val lambdaName: (Type) -> ReturnType = { argument: Type -> body }
						</code>
					</pre>
					<blockquote>If lambda expression has a single parameter, you can use the default name <code class="inline">it</code>.</blockquote>
					<br />
					<h4>Anonymous Function</h4>
					<p>
						Anonymous functions are used when you need more control over the function's return type or when you need to use the <code class="inline">return</code> statement to exit the function itself rather than the enclosing function.
					</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val lambdaName = fun(name: Type): Type {
								return value
							}
						</code>
					</pre>
					<blockquote>
						Opposite of anonymous function is called a named function.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Lambda Expression</h3>
				<div class="summary">
					Examples
				</div>
				<div class="content">
					<p>Function with one parameter and no return value:</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val greet: (String) -> Unit = { name -> println("Hello, $name!") }

							greet("World")
						</code>
					</pre>
					<p>If lambda expression has a single parameter, you can use the default name <code class="inline">it</code>:</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val greet: (String) -> Unit = { println("Hello, $it!") }

							greet("World")
						</code>
					</pre>
					<p>Function with two parameters and a return value:</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val multiply: (Int, Int) -> Int = { a, b -> a * b }

							val result = multiply(10, 20)
						</code>
					</pre>
					<p>
						Common examples of lambda function is the <code class="inline">forEach</code>:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val cities = listOf("Bangkok", "Barcelona", "Tokyo", "London", "New York")

							cities.forEach { city ->
								println(city)
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Anonymous Function</h3>
				<div class="summary">
					Examples
				</div>
				<div class="content">
					Anonymous function with one parameter and no return value:
					<pre>
							<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
								val greet = fun(name: String) {
									println("Hello, $name!")
								}

								greet("World")
							</code>
						</pre>
					Anonymous function with two parameters and a return value:
					<pre>
							<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
								val multiply = fun(a: Int, b: Int): Int {
									return a * b
								}

								val result = multiply(10, 20)
							</code>
						</pre>
				</div>
			</section>
			<section>
				<h3>Anonymous Function & Lambda Expression</h3>
				<div class="summary">
					Usage
				</div>
				<div class="content">
					<p>
						In summary, lambda expressions are more concise and are typically used for simpler functions,
						while anonymous functions provide more flexibility with explicit return types and return behavior.
					</p>
					<p>
						There are few use cases for lambda expressions and anonymous functions:
					</p>
					<ul>
						<li>Passing functions as arguments to higher-order functions</li>
						<li>Returning functions from other functions</li>
						<li>Defining local functions that are not needed outside the scope of the enclosing function</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Anonymous Function & Lambda Expression</h3>
				<div class="summary">
					Usage
				</div>
				<div class="content">
					<p>
						In this example, the <code class="inline">operation</code> function takes two integers and a lambda function as arguments.
					</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun operation(x: Int, y: Int, func: (Int, Int) -> Int): Int {
								return func(x, y)
							}
						</code>
					</pre>
					<p>
						The most common use way pass the function argument is:
					</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val result = operation(10, 20) { x, y -> x + y }
						</code>
					</pre>
					<p>
						Another possibility is to pass a function reference (it can be a named function or a member function):
					</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val multiply: (Int, Int) -> Int = { a, b -> a * b }

							val result = operation(10, 20, multiply)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Anonymous Function & Lambda Expression</h3>
				<div class="summary">
					Usage
				</div>
				<div class="content">
					<p>
						You can also return functions from other functions.
					</p>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun getCalculator(): (Int, Long, Double) -> Double {
								return { a, b, c -> a + b + c }
							}
						</code>
					</pre>
					<pre>
						<code	data-trim data-noescape data-line-numbers class="hljs kotlin">
							val calculator = getCalculator()

							val result = calculator(1, 2, 3.0)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<div>
						Create a function named <strong class="highlight">updateAtIndex</strong> that takes the following parameters:
						<ul>
							<li>An array of strings (<code class="inline">Array&lt;String&gt;</code>).</li>
							<li>A variable number of integer indices ((<code class="inline">vararg atIndex: Int</code>).</li>
							<li>A lambda function ((<code class="inline">func: (String) -> String</code>) that takes a string as an argument and returns a string.</li>
						</ul>
					</div>
					<div>
						<p>
							The function should return a new array (copy) of <code class="inline">Array&lt;String&gt;</code> where the elements at the specified indices are updated using the provided lambda function. If any of the specified indices are out of bounds, the function should throw an error with the message "Index out of bounds".
						</p>
						<strong>Example</strong>
						<p>Given the following input:</p>
						<ul>
							<li><code class="inline">array = ["a", "b", "c", "d", "e"]</code></li>
							<li><code class="inline">atIndex: = 1, 3</code></li>
							<li><code class="inline">func = { it.uppercase() }</code></li>
						</ul>
						<p>The function should return:</p>
						<code class="inline">["a", "B", "c", "D", "e"]</code>
					</div>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Extension Functions</h2>
			</section>
			<section>
				<h3>Extension functions</h3>
				<div class="summary">
					Extension functions allow adding new methods to existing classes without modifying their source code.
				</div>
				<div class="content">
					<div>
						<p>
							Extension functions are one of the most powerful and popular features of Kotlin.
							You define an extension function by prefixing the function name with the type you want to extend.
						</p>
					</div>
					<br />
					<div>
						<strong>Benefits of extension functions include:</strong>
						<ul>
							<li>Adding new functionality to existing classes which you may not have access to.</li>
							<li>Using extension functions to create a more fluent API and DSLs.</li>
							<li>Improving readability and maintainability of code by encapsulating and naming logic in extension functions.</li>
							<li>Using extension functions to transform objects into other objects.</li>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<h3>Extension functions: Examples</h3>
				<div class="summary">
					Adding new functionality to existing classes which you may not have access to.
				</div>
				<div class="content">
					<p>
						For example, you can add a new method to the <code class="inline">String</code> class to capitalize the first letter of each word in a sentence.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun String.capitalizeWords(): String {
								return this.split(" ").joinToString(" ") { it.capitalize() }
							}
						</code>
					</pre>
					<p>
						You can then use this extension function on any <code class="inline">String</code> object.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun main() {
								val sentence = "hello world from kotlin"
								println(sentence.capitalizeWords()) // Output: "Hello World From Kotlin"
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Extension functions: Examples</h3>
				<div class="summary">
					Using extension functions to create a more fluent API and DSLs.
				</div>
				<div class="content">
					<p>
						You can use extension functions to create a more fluent API by adding methods to existing classes that allow you to chain method calls together.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							data class Person(
								val name: String,
								val age: Int,
								val country: String
							)
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun List&lt;Person&gt;.filterByCountry(country: String): List&lt;Person&gt; {
								return this.filter { it.country.lowercase() == country.lowercase()) }
							}

							fun List&lt;Person&gt;.sortByName(): List&lt;Person&gt; {
								return this.sortedBy { person -> person.name }
							}
						</code>
					</pre>
					<p>
						You can then use these extension functions to create a more readable and expressive code.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val people = listOf(
								// list of people
							)

							val filteredPeople = people
								.filterByCountry("Thailand")
								.sortByName()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Extension functions: Examples</h3>
				<div class="summary">
					Improving readability and maintainability of code by encapsulating and naming logic in extension functions.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							data class Person(
								val name: String,
								val age: Int,
								val country: String
							)
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun Person.canDrinkBeer(): Boolean {
								val legalAge = when (country) {
									"USA" -> 21
									else -> 18
								}
								return age >= legalAge
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun main() {
								val person = Person("John", 21, "USA")
								println("${person.name} can drink beer: ${person.canDrinkBeer()}")
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Extension functions: Examples</h3>
				<div class="summary">
					Using extension functions to transform objects into other objects.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							data class Person(
								val name: String,
								val age: Int,
								val country: String
							)
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							data class Student(
								val name: String,
								val country: String,
								val dateEnrolled: LocalDate
							)
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun Person.toStudent() = Student(
								name = name,
								country = country,
								dateEnrolled = LocalDate.now()
							)
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val person = Person("John", 21, "USA")
    						val student = person.toStudent()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<div>
						<p>
							Implement the following extension functions ...
						</p>
						<strong class="highlight">A) Int extension</strong>
						<p>
							Implement an extension functions <code class="inline">isEven</code>  and <code class="inline">isOdd</code>
							for the <code class="inline">Int</code> class that returns <code class="inline">Boolean</code>.
						</p>
					</div>
					<br />
					<div>
						<strong class="highlight">B) Array extension</strong>
						<p>
							Create an extension function for the <code class="inline">Array&lt;String&gt;</code> class that will return a new array with the same elements repeated twice.
							<br />
							<br />
							For example, if the input array is <code class="inline">["a", "b", "c"]</code>, the output array should be <code class="inline">["a", "b", "c", "a", "b", "c"]</code>.
						</p>
					</div>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Scope Functions</h2>
			</section>
			<section>
				<h3>Scope Functions</h3>
				<div class="summary">
					Scope functions allow you to execute a block of code within the context of an object.
				</div>
				<div class="content">
					<p>
						When you use a scope function, you can access the object's properties and functions without having to use the object's name.
					</p>
					<p>
						The scope functions in Kotlin are
						<code class="inline">let</code>,
						<code class="inline">run</code>,
						<code class="inline">with</code>,
						<code class="inline">apply</code>,
						and <code class="inline">also</code>.
					</p>
					<p>
						Each scope function has a different context object and return value, which makes them useful for different use cases.
					</p>
					<br />
					<table style="font-size: 80%">
						<thead>
						<tr>
							<td><strong>Function</strong></td>
							<td><strong>Context object</strong></td>
							<td><strong>Return value</strong></td>
							<td><strong>Usage</strong></td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td><code class="inline">let</code></td>
							<td><strong>it</strong></td>
							<td>Result of the lambda expression</td>
							<td>Execute a block of code on the result of a call chain or to work with nullable objects</td>
						</tr>
						<tr>
							<td><code class="inline">run</code></td>
							<td><strong>this</strong></td>
							<td>Result of the lambda expression</td>
							<td>Often used when you want to perform multiple operations on an object and return a result</td>
						</tr>
						<tr>
							<td><code class="inline">with</code></td>
							<td><strong>this</strong></td>
							<td>Result of the lambda expression</td>
							<td>Execute a block of code on an object</td>
						</tr>
						<tr>
							<td><code class="inline">apply</code></td>
							<td><strong>this</strong></td>
							<td>The context object itself</td>
							<td>Typically used for initializing or configuring an object.</td>
						</tr>
						<tr>
							<td><code class="inline">also</code></td>
							<td><strong>it</strong></td>
							<td>The context object itself</td>
							<td>Perform additional operations on an object without changing the object itself</td>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>let</h3>
				<div class="summary">
					Execute a block of code on the result of a call chain or to work with nullable objects.
				</div>
				<div class="content">
					<p>
						The context object of the <code class="inline">let</code> function is referred to as <code class="inline">it</code>
						and the return value is the result of the lambda expression.
					</p>
					<p>
						The <code class="inline">let</code> function is particularly useful when used with a nullable types,
						because it allows us to chain multiple operations on a nullable object.
					</p>
					<br />
					<strong>Example:</strong> using <code class="inline">let</code> to work with nullable objects
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Message(
								val text: String?,
								var acknowledged: Boolean = false
							) {
								fun send(): Message {
									TODO("Response message")
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val message = Message(text = "Hello")

							val response = message.send()

							val text = response.text?.let {
								println("Received message: $it")
							}

							// process text
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>run</h3>
				<div class="summary">
					Often used when you want to perform multiple operations on an object and return a result.
				</div>
				<div class="content">
					<p>
						The context object of the <code class="inline">run</code> function is referred to as <code class="inline">this</code>
						and the return value is the result of the lambda expression.
					</p>
					<strong>Example 1:</strong> Using run to initialize an object
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Message(
								val text: String?,
								var acknowledged: Boolean = false
							) {
								fun send(): Message {
									TODO("Response message")
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val message = Message(text = "Hello").run {
								if (send().acknowledged) {
									println("Message acknowledged")
								} else {
									println("Message not acknowledged")
								}
								this
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>with</h3>
				<div class="summary">
					User when you want to execute a block of code on an object.
				</div>
				<div class="content">
					Example 1: Using run to initialize an object
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Message(
								val text: String?,
								var acknowledged: Boolean = false
							) {
								fun send(): Message {
									TODO("Response message")
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val message =  Message(text = "Hello")

							with(message) {
								if (send().acknowledged) {
									println("Message acknowledged")
								} else {
									println("Message not acknowledged")
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>apply</h3>
				<div class="summary">
					Typically used for initializing or configuring an object.
				</div>
				<div class="content">
					<strong>Example 1:</strong> Using apply to initialize an object
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Message(
								val text: String?,
								var acknowledged: Boolean = false
							) {
								fun send(): Message {
									TODO("Response message")
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							   val message =  Message(text = "Hello").apply {
									acknowledged = true
								}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>also</h3>
				<div class="summary">
					used when you want to perform additional operations on an object without changing the object itself.
				</div>
				<div class="content">
					<strong>Example 1:</strong> Using also to print the object
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Message(
								val text: String?,
								var acknowledged: Boolean = false
							) {
								fun send(): Message {
									TODO("Response message")
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val message = Message(text = "Hello")
								.also { println(it)  }

							val response = message.send()
								.also { println(it)  }
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<p>
						You have two data classes:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Person(
								val name: String,
								val contact: Contact
							)
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Contact(
								var email: String? = null,
								var phone: String? = null
							)
						</code>
					</pre>
					<p>
						Write a code that will create an instance of a person, for example:
					<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								val person = Person(
									name = "John",
									contact = Contact()
								)
							</code>
						</pre>
					</p>
					<p>
						Then use the scope functions to update the person's contact information. You can do all this in a main function.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Practice</h2>
			</section>
		</section>
	</div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,
		center: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
