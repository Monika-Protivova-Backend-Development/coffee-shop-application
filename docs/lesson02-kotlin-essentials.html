<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="./dist/reset.css">
	<link rel="stylesheet" href="./dist/reveal.css">
	<link rel="stylesheet" href="./dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="./plugin/highlight/vs.css">
</head>
<body>
<div class="reveal" >
	<div class="slides">
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<i>Week 1 | Lesson 2</i>
				<h1>Introduction to Kotlin</h1>
				<em>Essentials: variables, functions, control flow, classes</em><br />
				<em>Brief JVM/Java context (types, memory model)</em><br />
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Object-oriented programming</h2>
			</section>
			<section>
				<h3>Object-oriented programming</h3>
				<div class="summary">
					There are four main principles in OOP ...
				</div>
				<div class="content">
					<ol>
						<li>
							<strong>Encapsulation</strong><br />
							is a concept of controlling access to the internal state of an object, protecting it from unauthorized access and ensuring data integrity.
						</li>
						<li>
							<strong>Inheritance</strong><br />
							enables class to have the same behavior as another class by inheriting its properties and methods.
						</li>
						<li>
							<strong>Polymorphism</strong><br />
							allows us to define one interface or method that can have multiple implementations.
							It means that the same method or property could exhibit different behavior in different instances of object implementing given interface.
						</li>
						<li>
							<strong>Abstraction</strong><br />
							is a mechanism to represent the object features without exposing the actual implementation details.
							In other words, user of such object only needs to know what it does, not how it does it.
						</li>
					</ol>
					<p>
						<em>We will come back to these principles later in the course.</em>
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Kotlin Language Syntax</h2>
				<em>Overview</em>
			</section>
			<section>
				<h3>Program entry point</h3>
				<div class="summary">
					Program entry point is the first function that is executed when the program is run.
				</div>
				<div class="content">
					<ul>
						<li>
							All Kotlin files should have <code class="hljs inline">.kt</code> extension, for example <code class="hljs inline">MyProgram.kt</code>.
						</li>
						<li>
							In Kotlin, the main program entry point is defined as a top-level function,
							which means that it is not part of a <em>class</em>.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun main() {
										println("Hello world!")
									}
								</code>
							</pre>
						</li>
						<li>
							The main function may accept an <em>array of strings</em> as an argument,
							which can be used to pass command-line arguments to the program.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun main(args: Array&lt;String&gt;) {
										println("Number of arguments: " + args.size)
										for (arg in args) {
											println("Argument: $arg")
										}
									}
								</code>
							</pre>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Functions</h3>
				<div class="summary">
					Function is declared using the <code class="hljs inline">fun</code> keyword, followed by the function name,
					parameters in parentheses, return type, and function body enclosed in curly braces.
				</div>
				<div class="content">
					<ul>
						<li>
							Function may have zero or more parameters, and it may return a value, in which case the return type is specified.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun myFunction(arg1: Int, arg2: Int): Int {
										return arg1 + arg2
									}
								</code>
							</pre>
						</li>
						<li>
							If a function does not return a value, the return type is <code class="hljs inline">Unit</code>,
							but the return type can be omitted.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun myFunction(arg1: Int, arg2: Int) {
										println(arg1 + arg2)
									}
								</code>
							</pre>
						</li>
<!--						<li>-->
<!--							Function can also be defined as a single expression function,-->
<!--							in which case the return type can be omitted as it is inferred by the compiler.-->
<!--							<pre>-->
<!--								<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--									fun myFunction(arg1: Int, arg2: Int) = arg1 + arg2-->
<!--								</code>-->
<!--							</pre>-->
<!--						</li>-->
					</ul>
					<br />
					<em>We will talk more about functions in lesson 2.</em>
				</div>
			</section>
			<section>
				<h3>Variables</h3>
				<div class="summary">
					Variables in Kotlin are declared using the <code class="hljs inline">var</code> or <code class="hljs inline">val</code> keyword,
					followed by the variable name, type, and optional value.
				</div>
				<div class="content">
					<ul>
						<li>
							Variables declared with <code class="hljs inline">var</code> are <strong>mutable</strong> = their value can be changed during the program execution.
						</li>
						<li>
							Variables declared with <code class="hljs inline">val</code> are <strong>immutable</strong> = their value cannot be changed once it is assigned = they are read-only.
						</li>
						<li>
							You can omit type in case variable is declared and initialized at the same time, it will be inferred by the compiler.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									val myNumber = 42

									val myText = "Hello, world!"
								</code>
							</pre>
						</li>
						<li>
							If <strong>mutable</strong> variable is not initialized at the time of declaration, you must specify it's type.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									var myNumber: Int

									var myText: String
								</code>
							</pre>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Classes</h3>
				<div class="summary">
					Classes in Kotlin are declared using the <code class="inline">class</code> keyword, followed by the class name,
					an optional constructor, and the class body enclosed in curly braces.
				</div>
				<div class="content">
					<ul>
						<li>Classes can have properties, functions, and multiple constructors.</li>
						<li>Classes are also usually part of a package, which is a way to organize classes into namespaces.</li>
						<li>
							Example:
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									package com.package.domain

									class MyClass {
										var myVariable: Int = 42
										val foo: Foo = Foo()

										/*
										Block comment
										*/
										fun myFunction(number: Long): String {
											// important comment
											return foo.bar()
										}
									}
								</code>
							</pre>
						</li>
					</ul>
					<br />
					<em>We will talk more about classes in lesson 3.</em>
				</div>
			</section>
			<section>
				<h3>Printing</h3>
				<div class="summary">
					You can use <code class="hljs inline">print</code> function to print on the same line,
					and <code class="hljs inline">println</code> function to print with a new line at the end.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								print("Hello, ")  // prints on one line
								println("world!") // prints on with a new line at the end
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Comments</h3>
				<div class="summary">
					You can use <code class="hljs inline">//</code> for single-line comments
					and <code class="hljs inline">/* */</code> for multi-line comments.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							// single-line comment

							/*
							Multi-line comment
							*/
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Naming Conventions</h3>
				<div class="summary">
					Kotlin naming conventions are similar to Java naming conventions ...
				</div>
				<div class="content">
					<ul>
						<li>
							<span class="highlight">Package</span> name is always written in all-lowercase.
						</li>
						<li>
							<span class="highlight">Class or interface</span> name should be nouns in mixed case with the first letter of each internal word capitalized. Should be sufficiently descriptive.
						</li>
						<li>
							<span class="highlight">Method</span> name should be verb, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
						</li>
						<li>
							<span class="highlight">Variable</span> name should be in mixed case with a lowercase first letter. Internal words start with capital letters. Should be meaningful and descriptive
						</li>
						<li>
							<span class="highlight">Constants</span> name should be noun with each letter of internal word capitalized. Should be sufficiently descriptive.
						</li>
					</ul>
				<!--				<em style="font-size: 80%">-->
				<!--					Full set of recommendation by Oracle can be found <a href="https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html">here</a>.-->
				<!--				</em>-->
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Kotlin Data Types</h2>
			</section>
			<section>
				<h3>Data types</h3>
				<div class="summary">
					Java/Kotlin is a high-level programming language with automatic memory management, and no pointers (unlike C/C++).
				</div>
				<div class="content content-center content-100">
					<strong>Why is this still important for us to understand?</strong>
				</div>
			</section>
			<section>
				<h3>Kotlin Data Types</h3>
				<div class="summary">
					Kotlin data representation is based on Java data types,
					<br />
					but with some key differences ...
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<h4>Java</h4>
							<ul>
								<li>There are two groups of data types in Java - <strong>primitive</strong> and <strong>non-primitive</strong> types</li>
								<li>Primitive types are the basic data types that are built into the language.</li>
								<li>
									Primitive types
									<ul>
										<li>
											<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>boolean</code>
										</li>
									</ul>
								</li>
								<li>
									Non-primitive types
									<ul>
										<li>
											<code>String</code>, <code>Arrays</code>, <code>Classes</code>, ...
										</li>
									</ul>
								</li>
							</ul>
						</div>
						<div class="column">
							<h4>Kotlin</h4>
							<ul>
								<li>Kotlin has representation corresponding to Java primitive types, but unlike Java, they are all objects.</li>
								<li>Because they are objects, they have methods and properties.</li>
								<li>When Kotlin code gets compiled, the compiler will convert these objects to Java primitive types.</li>
							</ul>
						</div>
					</div>
				</div>
				<div class="content">
					<blockquote>
					<ul>
						<p>
							Knowing what JVM primitive type they compile to is important for understanding how they are stored in memory.
						</p>
						<p>
							Understanding memory management, garbage collection, and type systems is crucial for writing efficient code,
							avoiding memory leaks, and preventing issues like data loss from type mismatches.
						</p>
					</ul>
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Numeric Types</h3>
				<div class="content">
					<h4>Integer types</h4>
					<table style="width: 100%">
						<tbody>
						<tr><td><code>Byte</code></td><td>1 byte</td><td>whole number from -128 to 127</td></tr>
						<tr><td><code>Short</code></td><td>2 bytes</td><td>whole number from -32768 to 32767</td></tr>
						<tr><td><code>Int</code></td><td>4 bytes</td><td>whole number from -2147483648 to 2147483647</td></tr>
						<tr><td><code>Long</code></td><td>8 bytes</td><td>whole number from -9223372036854775808 to 9223372036854775807</td></tr>
						</tbody>
					</table>
					<br />
					<br />
					<h4>Unsigned Integer types</h4>
					<table style="width: 100%">
						<tbody>
						<tr><td><code>UByte</code></td><td>1 byte</td><td>whole number from 0 to 255</td></tr>
						<tr><td><code>UShort</code></td><td>2 bytes</td><td>whole number from 0 to 65535</td></tr>
						<tr><td><code>UInt</code></td><td>4 bytes</td><td>whole number from 0 to 4,294,967,295 (232 - 1)</td></tr>
						<tr><td><code>ULong</code></td><td>8 bytes</td><td>whole number from 0 to 18,446,744,073,709,551,615 (264 - 1)</td></tr>
						</tbody>
					</table>
					<br />
					<br />
					<h4>Floating-point types</h4>
					<table style="width: 100%">
						<tbody>
						<tr><td><code>Float</code></td><td>4 bytes</td><td>fractional number up to 7 decimal digits</td></tr>
						<tr><td><code>Double</code></td><td>8 bytes</td><td>fractional number up to 15 decimal digits</td></tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Numeric Types</h3>
				<div class="content">
					<h4>Integer types</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val index: Byte = 127
							val smallNumber: Short = 32767
							val number: Int = 2147483647
							val bigNumber: Long = 9223372036854775807L // notice L at the end
						</code>
					</pre>
					<h4>Unsigned integer types</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val uIndex: UByte = 255u // u indicates unsigned type
							val uSmallNumber: UShort = 65535u
							val uNumber: UInt = 4294967295u
							val uBigNumber: ULong = 18446744073709551615u
						</code>
					</pre>
					<h4>Floating-point types</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val decimalNumber: Float = 123.12346f // f indicates float type
							val preciseNumber: Double = 123.12345886230469
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Non-numeric Data Types</h3>
				<div class="content">
					<table>
						<tbody>
						<tr><td><code>Boolean</code></td><td>1 byte</td><td>value of true or false</td></tr>
						<tr><td><code>Char</code></td><td>2 bytes</td><td>a single 16-bit Unicode character</td></tr>
						<tr><td><code>String</code></td><td>approximately 2 bytes per character</td><td>UTF-16 encoded string of characters</td></tr>
						<tr><td><code>Array</code></td><td>depends</td><td>
							Fixed number of values of the same type or its subtypes.
						</td></tr>
						</tbody>
					</table>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val isTrue: Boolean = true
							val character: Char = 'A'
							val text: String = "Hello, world!"

							val arrayOfStrings = arrayOf("hello", "world", "kotlin", "is", "fun")

							println(arrayOfStrings[2]) // will print "kotlin"
						</code>
					</pre>
					<em>Unless there are specific memory performance requirements, you should prefer using Collections over Arryas.</em>
				</div>
			</section>
<!--			<section>-->
<!--				<h3>Arrays</h3>-->
<!--				<div class="summary">-->
<!--					Arrays are used to store multiple values of the same type in one variable.-->
<!--					<br />-->
<!--					Arrays are of fixed size, which means that once you declare an array, you cannot change its size.-->
<!--				</div>-->
<!--				<div class="content">-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							val languages = arrayOf("Java", "Kotlin", "Python")-->

<!--							println(languages.size)  // will print 3-->
<!--							println(languages[1])    // will print "Kotlin"-->
<!--						</code>-->
<!--					</pre>-->
<!--					<p>-->
<!--						You can change value of an array by its index (zero-based).-->
<!--						<pre>-->
<!--							<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--								languages[2] = "JavaScript"-->
<!--							</code>-->
<!--						</pre>-->
<!--					</p>-->
<!--					<p>-->
<!--						If you try to assign value outside of array bound, you will get an error.-->
<!--						<pre>-->
<!--							<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--								println(languages[3])  // java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 0-->
<!--							</code>-->
<!--						</pre>-->
<!--					</p>-->
<!--					<p>-->
<!--						Arrays are fixed size, but you can create a new array with a different size and copy values from the old array.-->
<!--						<pre>-->
<!--							<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--								val updatedLanguage = languages.plus("Go") // will contain "Java", "Kotlin", "Python", "Go"-->
<!--							</code>-->
<!--						</pre>-->
<!--					</p>-->
<!--					<p>-->
<!--						You can also create an empty array. In this case, you need to specify the type of the array.-->
<!--						<pre>-->
<!--							<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--								val emptyArray = emptyArray&lt;String&gt;()-->
<!--							</code>-->
<!--						</pre>-->
<!--					</p>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h3>Collections</h3>-->
<!--				<div class="summary">-->
<!--					Collections are similar to arrays, but they are more flexible and have more features at the cost-->
<!--					of being less efficient in terms of memory and performance.-->
<!--				</div>-->
<!--				<div class="content">-->
<!--					<p>-->
<!--						The main difference between arrays and collections is that collections can grow or shrink in size.-->
<!--						They generally provide more functionality and are easier to work with than arrays, but also-->
<!--						are less efficient in terms of memory and performance.-->
<!--					</p>-->
<!--					<p>-->
<!--						There are several types of collections in Kotlin, such as <code>List</code>, <code>Set</code>, <code>Map</code>, etc.-->
<!--					</p>-->
<!--					<p>-->
<!--						Unlike and array, which is basic data structure, collections are interfaces that define a set of operations that can be performed on a group of objects.-->
<!--					</p>-->
<!--					<p>-->
<!--						<em>We will learn in detail about collections in the future lesson.</em>-->
<!--					</p>-->
<!--				</div>-->
<!--			</section>-->
			<section>
				<h3>Any type</h3>
				<div class="summary">
					<code class="hljs inline">Any</code> is the root of the Kotlin class hierarchy.
					<br />
					This means that all type classes in Kotlin are subclasses of <code class="hljs inline">Any</code>.
				</div>
				<div class="content">
					<p>
						Anytime we don't know the type of variable, parameter or return type,
						we can use <code class="hljs inline">Any</code> to accept any type.
						However, this is not recommended and should be used with caution.
					</p>
					<p>
						Any type is equivalent to Java's <code class="hljs inline">Object</code> type.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val someValue: Any = "This is a string"

							if (someValue is String) {
								println("The value is a string")
							} else {
								println("The value is not a string")
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>null</h3>
				<div class="summary">
					In Java/Kotlin, null is a special value that represents the absence of an instance.
					<br />
					It is used to indicate that a reference variable doesn't point to any memory location or object.
					<br />
					(Therefore by definition, primitive types cannot be null)
				</div>
				<div class="content">
					<p>
						Some key point to keep in mind when working with nulls in Java/Kotlin code ...
					</p>
					<ul>
						<li>
							Since Kotlin and Java are interoperable, you may need to explicitly handle null values when calling Java methods from Kotlin.
						</li>
						<li>
							In Java
							<ul>
								<li>you can assign null to any <strong>reference variable</strong> (non-primitive types: objects, array, interface, etc)</li>
								<li>for object reference types, the default value is null when they are defined as class members and not explicitly initialized</li>
								<li>If you try to invoke a method or access a property on a reference variable with a null value, you will get a <strong>NullPointerException</strong>. This is a runtime exception in Java.</li>
							</ul>
						</li>
						<li>
							In Kotlin, object references that may hold null values must be explicitly declared as <strong>nullable</strong> types.
						</li>

						<li>
							You can use null in comparison operations. For example, to check if an object is null, you can use if (object == null).
						</li>
						<li>
							Assigning null to a variable makes it eligible for <strong>garbage collection</strong> if there are no other references to the object.
						</li>
						<li>
							Null can be passed as an argument to a method and can also be returned from a method.
						</li>
					</ul>
				</div>
			</section>

			<section>
				<h3>Nullables</h3>
				<div class="summary">
					Nullables are Kotlin types that can hold a null value.
					<br />
					Any type can be nullable by adding a <code class="hljs inline">?</code> after the type.
					<br />
					<br />
					When working with nullable types, you need to handle null values to avoid <strong>NullPointerException</strong>.
				</div>
				<div class="content">
					<div class="row">
						<pre>
							<code data-trim data-noescape class="hljs kotlin">
								val nullableNumber: Int? = null
								val nullableText: String? = null
							</code>
						</pre>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							You can use the <code class="hljs inline">?.</code> operator to safely access properties or methods of nullable types.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									nullableNumber?.toString()
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							You can use the <code class="hljs inline">!!</code> operator to tell the compiler that you are sure the value is not null.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									nullableNumber!!.toString()
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							You can also use the <code class="hljs inline">?:</code> elvis operator to provide a default value if the value is null.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val text = nullableText ?: "default"
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							Use the <code class="hljs inline">let</code> function to execute a block of code only if the value is not null.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									nullableText?.let { printText(it) }
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Type inference & Type checks</h3>
				<div class="summary">
					Type inference is a feature that allows the compiler to automatically determine the data type of a variable based on the value assigned to it.
				</div>
				<div class="content">
					<p>
						For example, this is how you can declare a variable with type inference:
						<pre>
							<code data-trim data-noescape class="hljs kotlin">
								val number = 42             // type inferred as Int
								val text = "Hello, world!"  // type inferred as String
							</code>
						</pre>
					</p>
					<p>
						You can check the type of variable using the <code class="hljs inline">is</code> operator.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun getSomething(): Any {
								return 1234567890
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val something = getSomething()

							println(something is Int)			 // true
							println(something is Long)			 // false
							println(something::class.simpleName) // Int
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Type Conversion</h3>
				<div class="summary">
					Type conversion is a method of converting one data type to another.<br />
					Keep in mind, that type conversion may result in data loss!
				</div>
				<div class="content">
					<h4>Type Casting</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun getSomething(): Any {
								return 1234567890
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val something = getSomething()

							// Explicit type casting, only works if the value is of the same type
							val number = something as Int
						</code>
					</pre>
					<h4>Type Conversion</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val number = 1234567890
							val bigNumber = number.toLong() // Type conversion, no data loss
							val smallNumber = number.toShort() // Type conversion with DATA LOSS!
						</code>
					</pre>
					<p>
						Assigning smaller data type to larger data type - generally doesn't result in data loss.
					</p>
					<p>
						Assigning larger data type to smaller data type - may result in data loss.
					</p>
				</div>
			</section>
			<section>
				<h3>Advanced ...</h3>
			</section>
			<section>
				<h3>The two's complement</h3>
				<div class="summary">
					In Java/Kotlin, two's complement is used for the representation of signed integers.
					A negative number is represented as the two's complement of its absolute value.
					This allows positive and negative numbers to be added together directly.
				</div>
				<div class="content">
					<ul>
						<li>
							<strong>For positive integers</strong>, the two's complement representation is the same as their binary representation.
						</li>
						<li>
							<strong>For negative integers</strong>, you use binary representation of the absolute value of the number, then you invert each bit, and finally add 1 to the least significant bit (LSB).
						</li>
					</ul>
					<blockquote>
						<strong>Example: Binary representation of -5</strong>
						<ol>
							<li>The binary representation of absolute value of -5 (=5) is <code>0101</code></li>
							<li>Inverting each bit gives you <code>1010</code></li>
							<li>Adding 1 to the least significant bit gives you the binary representation of -5, which is: <code>1011</code></li>
						</ol>
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Literal constants for numbers</h3>
				<div class="content">
					<p>
						It is sometimes practical to represent data in binary or hexadecimal format to make the code more readable.
					</p>
					<p>
						You do that by prefixing the number with <code><strong>0b</strong></code> followed by 1s and 0s for binary representation,
						<br />
						or <code><strong>0x</strong></code> followed by characters or hexadecimal representation.
					</p>
					<table style="width: 100%">
						<tbody>
						<tr>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										fun main() {
											val binaryInt = 0b00001010
											println(binaryInt) 			// prints 10
											println(binaryInt == 10) 	// prints true
										}
									</code>
								</pre>
							</td>
							<td>
								<strong>Examples:</strong>
								<br />
								<br />
								<code>0b0</code> = 0<br />
								<code>0b1</code> = 1<br />
								<code>0b00001010</code> = 10<br />
							</td>
						</tr>
						<tr>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										fun main() {
											val hexInt = 0x00AA
											println(hexInt) 		// prints 170
											println(hexInt == 170) 	// prints true
										}
									</code>
								</pre>
							</td>
							<td>
								<strong>Examples:</strong>
								<br />
								<br />
								<code>0x0</code> = 0<br />
								<code>0xF</code> = 15<br />
								<code>0x00AA</code> = 170<br />
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Arrays</h2>
			</section>
			<section>
				<h3>Arrays</h3>
				<div class="summary">
					Array is a <span class="highlight">fixed-size</span> sequential collection of elements of the same type.
				</div>
				<div class="content">
					<div>
						<h4 class="highlight">Declaration and Initialization</h4>
						<ul>
							<li>Arrays can be declared using the <code class="inline">arrayOf&lt;Type&gt;()</code> function.</li>
							<li>Arrays are fixed-size, meaning their size cannot be changed once created.</li>
						</ul>
					</div>
					<br />
					<div>
						<h4 class="highlight">Type-Safety</h4>
						<ul>
							<li>
								Arrays in Kotlin are type-safe - they can only hold elements of the specified type (and its subtypes).
								<br />
								<sub>
									If array contains elements of different types, the type of the array is inferred to be the least common supertype of the elements,
									<br />
									or <code class="inline">Any</code> in case of no common supertype.
								</sub>
							</li>
							<li>The type declaration can be omitted if the type of the array can be inferred from the elements passed to the function.</li>
						</ul>
					</div>
					<br />
					<div>
						<h4 class="highlight">Access and Modification</h4>
						<ul>
							<li>
								Elements can be accessed or modified using their index and <code class="inline">[]</code> operator. Arrays are zero-based
								<br />
								<sub>For example <code class="inline">array[0]</code> will access first element.
								</sub>
							</li>
							<li>Modifying an element using an index that is out of bounds will throw an <code class="inline">ArrayIndexOutOfBoundsException</code>.</li>
							<li>Arrays can be iterated using loops.</li>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<h3>Array Declaration and Initialization</h3>
				<div class="content">
					<ul>
						<li>
							Arrays can be declared using the <code class="inline">arrayOf&lt;Type&gt;()</code> function.
							<br />
							<sub>Type declaration can be omitted if the type of the array can be inferred from the elements passed to the <code class="inline">arrayOf()</code> function.</sub>
						</li>
						<li>
							Arrays in Kotlin are <strong class="highlight">type-safe</strong> - they can only hold elements of the specified type.
							<br />
							<sub>
								If array contains elements of different types, the type of the array is inferred to be the least common supertype of the elements,
								<br />
								or <code class="inline">Any</code> in case of no common supertype.
							</sub>
						</li>
						<li>Arrays are <strong class="highlight">fixed-size</strong>, meaning their size cannot be changed once created.</li>
					</ul>
					<pre data-trim>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							// Declaring an array of integers
							val numbers = arrayOf(1, 2, 3, 4, 5)

							// Declaring an array of strings
							val cities = arrayOf("Bangkok", "Beijing", "Tokyo", "London", "Paris")

							// Declaring an array of mixed types
							val mixed = arrayOf(1, "Bangkok", 3.14, 'A', true)

							val empty = emptyArray&lt;String&gt;() // size 0

							val arrayOfNulls = arrayOfNulls&lt;String&gt;(5) // size 5, all elements are null
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Array Access and Modification</h3>
				<div class="content">
					<ul>
						<li>
							Elements can be accessed or modified using their index and <code class="inline">[]</code> operator.
							Arrays are <strong class="highlight">zero-based</strong>.
							<br />
							<sub>For example <code class="inline">array[0]</code> will access first element.
							</sub>
						</li>
						<li>Modifying an element using an index that is out of bounds will throw an <code class="inline">ArrayIndexOutOfBoundsException</code>.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val array = arrayOf(1, 2, 3, 4, 5)

							// updating an element on index 4 (5th element)
							array[4] = 42

							// accessing an element on index 4 (5th element)
							println(array[4])

							// accessing an element on index 5 (6th element) - will throw ArrayIndexOutOfBoundsException
							try {
								println(array[5])
							} catch (e: ArrayIndexOutOfBoundsException) {
								println(e.message)
							}
						</code>
					</pre>
					You can get size of the array using <code class="inline">size</code> property.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							println(array.size) // prints 5
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Array Operations</h3>
				<div class="summary">
					Given and array, some of the common operations on arrays include ...
				</div>
				<div class="content">
					<div>
						Iterating an array using a <code class="inline">for</code> loop or <code class="inline">forEach</code> function.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								for (element in array) {
									println(element)
								}
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								array.forEach { println(it) }
							</code>
						</pre>
						Filtering an array
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								val filtered = array.filter { it % 2 == 0 }
							</code>
						</pre>
						Checking if an array contains an element
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								array.contains(3) // returns true
							</code>
						</pre>
						Sorting, reversing, and shuffling an array
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								val sorted = array.sort() // in ascending order

								val reversed = array.reverse()

								val shuffled = array.shuffle()
							</code>
						</pre>
					</div>
					<div>
						<em>
							We will talk more about array and collection operations in the next lessons.
						</em>
					</div>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Operators</h2>
			</section>
			<section>
				<h3>Operators</h3>
				<div class="content content-center content-100">
					<ul>
						<li>Assignment operators</li>
						<li>Arithmetic operators</li>
						<li>Comparison operators</li>
						<li>Logical operators</li>
						<li><em>Bitwise operators</em></li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Assignment Operators</h3>
				<div class="summary">
					Assignment operators are used to assign value to <strong>variable</strong> or <strong>constant</strong>.
				</div>
				<div class="content">
					Variables and constants don't need to have explicit type declaration,
					in case the compiler can infer the type from the value assigned to it.
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val number = 3
							val text = "Hello"
							val date = LocalDate()
						</code>
					</pre>
					Variables and constants can be declared as <strong>read-only</strong>, using <code>val</code> keyword,
					or <strong>mutable</strong>, using <code>var</code> keyword.
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									var name: String = "John"
									name = "Jane"
									println(name)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Mutable variable value can be changed during the program execution.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val name: String = "John"
									name = "John"
									println(name)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							This will throw an error, because name is declared as read-only.
						</div>
					</div>
				</div>
				<br />
				<blockquote>
					Can you think of reason why we would want to declare a variable as read-only and reasons why we would want to declare a variable as mutable?
				</blockquote>
			</section>
			<section>
				<h3>Arithmetic Operators</h3>
				<div class="summary">
					Given two variables <code class="hljs inline">var a = 5</code> and <code class="hljs inline">var b = 2</code>.
				</div>
				<div class="content" style="font-size: 70%">
					<table>
						<tbody>
						<tr>
							<td><code>+</code></td>
							<td>addition</td>
							<td style="min-width: 300px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val sum = a + b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, sum = 7
							</td>
						</tr>
						<tr>
							<td><code>-</code></td>
							<td>subtraction</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val difference = a - b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, difference = 3
							</td>
						</tr>
						<tr>
							<td><code>*</code></td>
							<td>multiplication</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val product = a * b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, product = 10
							</td>
						</tr>
						<tr>
							<td><code>/</code></td>
							<td>division</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val quotient = a / b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, quotient = 2 (integer division)
							</td>
						</tr>
						<tr>
							<td><code>%</code></td>
							<td>modulus</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val remainder = a % b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, remainder = 1
							</td>
						</tr>
						<tr>
							<td><code>++</code></td>
							<td>increment (by 1)</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val increment1 = ++a
											val increment2 = a++
										</code>
									</pre>
							</td>
							<td>
								a = 7, increment1 = 6, increment2 = 6
							</td>
						</tr>
						<tr>
							<td><code>--</code></td>
							<td>decrement (by 1)</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val decrement1 = --b
											val decrement2 = b--
										</code>
									</pre>
							</td>
							<td>
								b = 1, decrement1 = 0, decrement2 = 0
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Arithmetic Operators</h3>
				<blockquote style="font-size: 80%">
					Notice ++ and -- can be put before or after a value. What is the difference?
					<br />
					<br />
					What will this print?
					<pre>A)
						<code data-trim data-noescape class="hljs kotlin">
							var a = 0
							println(a++)
						</code>
						<span class="fragment fade-in">0, because is incremented (by 1) after it is printed</span>
					</pre>
					<pre>B)
						<code data-trim data-noescape class="hljs kotlin">
							var a = 0
							println(++a)
						</code>
						<span class="fragment fade-in">1, because is incremented (by 1) before it is printed</span>
					</pre>
					<pre>C)
						<code data-trim data-noescape class="hljs kotlin">
							val a: Int = 5
							val b: Int = 3

							println(a / b)
						</code>
						<span class="fragment fade-in">
							1, because 5 / 3 = 1.666666666666667, but since it is stored as integer, the decimal places are dropped
						</span>
					</pre>
					<pre>D)
						<code data-trim data-noescape class="hljs kotlin">
							val a: Int = 5
							val b: Int = 3

							println(a % b)
						</code>
						<span class="fragment fade-in">
							2, because remainder of integer 5 /3 is 2
						</span>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Comparison Operators</h3>
				<div class="summary">
					As the name suggest, comparison operators are used for comparing values.
					<br />
					They always yield a <b>boolean</b> value.
				</div>
				<div class="content">
					<table>
						<tbody>
						<tr>
							<td><code>==</code></td>
							<td>equals</td>
							<td style="min-width: 300px">
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isEqual = a == b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>!=</code></td>
							<td>not equals</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isNotEqual = a != b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>></code></td>
							<td>is greater</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isGreater = a > b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code><</code></td>
							<td>is less</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isLess = a > b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>>=</code></td>
							<td>is greater or equal</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isGreaterOrEqual = a >= b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code><=</code></td>
							<td>is less or equal</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isLessOrEqual = a >= b
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Comparison Operators</h3>
				<blockquote>
					Given these values, what will be the value of <b>result</b>?
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a = 5
							val b = 3
							val c = 2
						</code>
					</pre>
					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a > b
						</code>
					</pre>
					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a <= b
						</code>
					</pre>
					<pre>C)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a > (b + c)
						</code>
					</pre>
					<pre>D)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a >= (b + c)
						</code>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Logical Operators</h3>
				<div class="summary">
					Logical operators are used to evaluate logic between variables or values.
					<br />
					They always yields boolean value.
				</div>
				<div class="content">
					<table>
						<tbody>
						<tr>
							<td><code>&&</code></td>
							<td>logical and</td>
							<td>returns true if both statements are true</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val isTrue = statement1 && statement2
										</code>
									</pre>
							</td>
						</tr>
						<tr>
							<td><code>||</code></td>
							<td>logical or</td>
							<td>returns true if either statement is true</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val isEitherTrue = statement1 || statement2
										</code>
									</pre>
							</td>
						</tr>
						<tr>
							<td><code>!</code></td>
							<td>logical not</td>
							<td>reverses the result</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val neitherIsTrue = !(statement1 || statement2)
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>and</code></td>
							<td>logical and</td>
							<td>
								works same as && but doesn't short-circuit
							</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isTrue = statement1 and statement2
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>or</code></td>
							<td>logical or</td>
							<td>
								works same as || but doesn't short-circuit
							</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val neitherIsTrue = !(statement1 or statement2)
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
				<div>
					<blockquote>
						Short circuiting means that if the first part of the statement is false,
						the second part will not be evaluated.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Logical Operators</h3>
				<blockquote style="font-size: 80%">
					Given two string variables that can have values <code>cat</code>, <code>dog</code>, or <code>null</code>.
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val pet1: String? = "cat"
							val pet2: String? = null
						</code>
					</pre>

					How would you test if ...

					<br />
					<br />
					A) pet1 and pet2 are the same kind of pet?
					<div class="fragment fade-in">
						<pre >
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val hasTwoSamePets = pet1 == pet2
							</code>
						</pre>
					</div>

					B) pet1 and pet2 are both cats?
					<div class="fragment fade-in">
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val has2Cats = pet1 == "cat" && pet2 == "cat"
							</code>
						</pre>
					</div>

					C) At least one of pet1 and pet2 is a cat?
					<div class="fragment fade-in">
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val hasACat = pet1 == "cat" || pet2 == "cat"
							</code>
						</pre>
					</div>

					D) At least one of pet1 and pet2 is a pet (not null)?
					<div class="fragment fade-in">
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val hasAPet = pet1 != null || pet2 != null
							</code>
						</pre>
					</div>
				</blockquote>
			</section>
			<section>
				<h3>Something more ...</h3>
			</section>
			<section>
				<h3>Bitwise Operators</h3>
				<div class="content">
					<table style="font-size: 60%">
						<tbody>
						<tr>
							<td><code>and</code></td>
							<td>binary and</td>
							<td>sets bit to 1 if both bits at the same positions are 1</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101
											val b = 3 // binary: 0011

											val result = a and b // binary: 0001, decimal: 1
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0001</code>, decimal: <code>1</code>
							</td>
						</tr>
						<tr>
							<td><code>or</code></td>
							<td>binary or</td>
							<td>sets bit to 1 if either of bits at the same positions are 1</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101
											val b = 3 // binary: 0011

											val result = a or b // binary: 0111, decimal: 7
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0111</code>, decimal: <code>7</code>
							</td>
						</tr>
						<tr>
							<td><code>xor</code></td>
							<td>binary xor</td>
							<td>sets bit to 1 if of bits at the same positions are different</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101
											val b = 3 // binary: 0011

											val result = a xor b // binary: 0110, decimal: 6
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0110</code>, decimal: <code>6</code>
							</td>
						</tr>
						<tr>
							<td><code>shl</code></td>
							<td>signed left shift</td>
							<td>moves all bits by a given number of bits to the left</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101

											val result = a shl 1 // binary: 1010, decimal: 10
										</code>
									</pre>
							</td>
							<td>
								binary: <code>1010</code>, decimal: <code>10</code>
							</td>
						</tr>
						<tr>
							<td><code>shr</code></td>
							<td>signed right shift</td>
							<td>moves all bits by a given number of bits to the right</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101

											val result = a shr 2 // binary: 0001, decimal: 1
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0001</code>, decimal: <code>1</code>
							</td>
						</tr>
						<tr>
							<td><code>ushr</code></td>
							<td>unsigned right shift</td>
							<td>same as the signed right shift, but the vacant leftmost position is filled with 0 instead of the sign bit</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val a = -5 // binary equivalent of -5: 11111111111111111111111111111011

										val result = a ushr 1 // shifts right with zero fill
									</code>
								</pre>
							</td>
							<td>
	<!--							binary: <code>01111111111111111111111111111101</code>, decimal: <code>2147483645</code>-->
							</td>
						</tr>
						<tr>
							<td><code>.inv()</code></td>
							<td>binary complement operator</td>
							<td>flips all the bits of the operand 1s become 0s, and 0s become 1s</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101

											val result = a.inv() // binary: 1010, decimal: -6
										</code>
									</pre>
							</td>
							<td>
								binary: <code>1010</code>, decimal: <code>-6</code>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Bitwise Operators</h3>
				<blockquote style="min-width: 800px; font-size: 80%;">
					Imagine you have a <b>byte</b> stored in 1 byte (=8 bits), for example 8, which is stored as
					<code>00001000</code>
					<br />
					<br />
					If you perform following bit shift, what number do you get?
					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byte = 8
							val result = number << 1
						</code>
						<span class="fragment fade-in">
							The result is 16:<br />
							In binary: 1000 <- 10000
						</span>
					</pre>
					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byte = 8
							val result = number << 3
						</code>
						<span class="fragment fade-in">
							The result is 64:<br />
							In binary: 1000 <--- 1000000
						</span>
					</pre>
					<pre>C)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byet = -8
							val result = number >> 2
						</code>
						<span class="fragment fade-in">
							The result is -2:<br />
							In binary: 11111111111111111111111111111000 --> 11111111111111111111111111111110
						</span>
					</pre>
					<pre>D)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byte = -8
							val result = number >>> 2
						</code>
						<span class="fragment fade-in">
							The result is 1073741822:<br />
							In binary: 11111111111111111111111111111000 --> __111111111111111111111111111110
						</span>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Bitwise Operators</h3>
				<blockquote style="font-size: 80%">

					What will be the result of following bit operations?

					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val b: Byte = 81 // 01010001
							val result = a & b
						</code>
						<span class="fragment fade-in">
							The result is 17:<br />
							In binary: 00010101 & 01010001 = 00010001
						</span>
					</pre>

					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val b: Byte = 81 // 01010001
							val result = a | b
						</code>
						<span class="fragment fade-in">
							The result is 85:<br />
							In binary: 00010101 & 01010001 = 01010101
						</span>
					</pre>

					<pre>C)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val b: Byte = 81 // 01010001
							val result = a ^ b
						</code>
						<span class="fragment fade-in">
							The result is 68:<br />
							In binary: 00010101 & 01010001 = 01000001
						</span>
					</pre>

					<pre>D)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val result = ~a
						</code>
						<span class="fragment fade-in">
							The result is -22:<br />
							In binary: 00010101 -> 11101010
						</span>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Addition Assignment</h3>
				<div class="summary">
					Combines assignment operators with arithmetic operators.
				</div>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var number = 0

							number += 3 // equivalent: number = number + 3

							number -= 3 // equivalent: number = number - 3

							number *= 3 // equivalent: number = number / 3

							number /= 3 // equivalent: number = number * 3

							number %= 3 // equivalent: number = number % 3
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Conditionals</h2>
				<em>Control Flow Statements</em>
			</section>
			<section>
				<h3>if ... else if ... else</h3>
				<div class="summary">
					Because Kotlin, like Java is based on C++ syntax, you can expect similar control flow statements.
				</div>
				<div class="content">
					You can write just simple <b>if</b> statement ...
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							if (a <= b) {
								// execute if condition is met
							}
						</code>
					</pre>

					<b>else</b> branch is not required, but it is highly recommendable ...
					<pre>
					<code data-line-numbers data-trim data-noescape class="hljs kotlin">
						if (a <= b) {
							// execute if condition is met
						} else {
							// execute if condition is NOT met
						}
					</code>
				</pre>
					You can also evaluate multiple conditions with <b>else if</b>.
					<pre>
					<code data-line-numbers data-trim data-noescape class="hljs kotlin">
						if (a < b) {
							// execute if first condition is met
						} else if (a == b) {
							// execute if second condition is met
						} else if (a == null) {
							// execute if third condition is met
						} else {
							// execute if no condition is NOT met
						}
					</code>
				</pre>
				</div>
			</section>
			<section>
				<h3>if ... else if ... else</h3>
				<div class="summary">
					Kotlin allows you to return value from if else statement.
				</div>
				<div class="content">
					Traditionally, you would write this code ...
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var result: String? = null

							if (a < b) {
								result = "a is less than b"
							} else if (a == b) {
								result = "a is equal to b"
							} else {
								result = "a is greater than b"
							}
						</code>
					</pre>
					Kotlin allows you to write this in a more concise way.
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = if (a < b) {
								"a is less than b"
							} else if (a == b) {
								"a is equal to b"
							} else {
								"a is greater than b"
							}
						</code>
					</pre>
					Kotlin has no tenary operator like Java, but you can use if else as a replacement.
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = if (a < b) "a is less than b" else "a is greater than or equal to b"
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>when</h3>
				<div class="summary">
					One of the most powerful control flow statements in Kotlin is <b>when</b>.
					<br />
					It is similar to <b>switch</b> in Java, but it is more powerful.
				</div>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val randomInt = arrayOf(0, 1, 2, 3, 4, 5).random()
						</code>
					</pre>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = when (randomInt) {
								0 -> "Zero"
								1 -> "One"
								2 -> "Two"
								3 -> "Three"
								4 -> "Four"
								5 -> "Five"
								else -> "Too much"
							}
						</code>
					</pre>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = when {
								randomInt < 0 -> "Less than 0"
								randomInt == 0 -> "Zero"
								else -> "Greater than 0"
							}
						</code>
					</pre>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = when (randomInt) {
								0 -> "Zero"
								in 1..3 -> "Between 1 and 3"
								in 3..5 -> "Between 3 and 5"
								else -> "Too much"
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>For Loop</h3>
				<div class="summary">
					The for loop is used to iterate over anything that provides an iterator, such as a range, array, or a collection.
				</div>
				<div class="content">
					<div>
						The basic syntax of for loop is ...
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								for (item in collection) println(item)
							</code>
						</pre>
						or the body can be a block ...
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val languages = arrayOf("Java", "Kotlin", "Python")

								for (language in languages) {
									println(language)
								}
							</code>
						</pre>
					</div>
					<div>
						You can also use range expression to iterate over a range of numbers.
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								for (i in 10 downTo 0 step 2) {
									println(i)
								}
							</code>
						</pre>
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								for (i in 1..5) {
									println(i)
								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h3>While Loop / Do While Loop</h3>
				<div class="summary">
					While loop is used to execute a block of code repeatedly as long as a given condition is true.
				</div>
				<div class="content">
					<p>The <b>while</b> evaluates condition at the beginning of the loop block, before any code is executed.</p>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							while (condition) {
							  // code block to be executed
							}
						</code>
					</pre>
					<p>The <b>do while</b> first executes code block once, and evaluates condition the condition.</p>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							do {
							  // code block to be executed
							} while (condition)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>While Loop / Do While Loop</h3>
				<blockquote>
					How may times will "Ahoy!" be printed?
					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var counter = 10

							while (counter < 10) {
								println("Ahoy!")
								counter++
							}
						</code>
						<span class="fragment fade-in">0 - it will never be printed</span>
					</pre>
					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var counter = 10

							do {
								println("Ahoy!")
								counter++
							} while (counter < 10)
						</code>
						<span class="fragment fade-in">1 - once</span>
					</pre>
				</blockquote>
			</section>
<!--			<section>-->
<!--				<h4>For Loop</h4>-->
<!--				<blockquote>-->
<!--					How many times will this loop execute and what will be the values printed?-->
<!--					<pre>-->
<!--							<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--								for (i in 1 .. 10 step 2) {-->
<!--									println(i)-->
<!--								}-->
<!--							</code>-->
<!--						</pre>-->
<!--					<div class="fragment fade-in">-->
<!--						5 times. Values printed will be 1, 3, 5, 7 and 9.-->
<!--					</div>-->
<!--				</blockquote>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>For Each Loop</h4>-->
<!--				<div style="text-align: left">-->
<!--					<p>If you have an array, can iterate it using for loop.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							String[] languages = {"Java", "Python", "C++", "JavaScript"}-->

<!--							for (int i = 0 i < languages.length i++) {-->

<!--								System.out.println(languages[i])-->

<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--					<p>You can also use more convenient <b>for each</b> loop.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							String[] languages = {"Java", "Python", "C++", "JavaScript"}-->

<!--							for (String language : languages) {-->

<!--								System.out.println(language)-->

<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>Break / Continue</h4>-->
<!--				<div style="text-align: left">-->
<!--					<p>The <b>break</b> statement is used to end the loop immediately.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							for (int i = 0 i < x i++) {-->

<!--								if (breakCondition) {-->
<!--									break-->
<!--								}-->

<!--							}-->
<!--							// if breakCondition was met, the loop will end-->
<!--						</code>-->
<!--					</pre>-->
<!--					<p>The <b>continue</b> statement is end current iteration, but the loop will continue with next iteration.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							for (int i = 0 i < x i++) {-->

<!--								if (continueCondition) {-->
<!--									continue-->
<!--								}-->

<!--								// if continueCondition was met, this code will not be executed-->
<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>Break / Continue</h4>-->
<!--				<blockquote>-->
<!--					What values will be printed?-->
<!--					<pre>-->
<!--					<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--						int maxValue = 10-->
<!--						int significantValue = 7-->

<!--						for (int i = 0 i < maxValue i++) {-->

<!--							if (i == significantValue) {-->
<!--								break-->
<!--							}-->

<!--							System.out.println(i)-->
<!--						}-->
<!--					</code>-->
<!--					<span class="fragment fade-in">-->
<!--						1, 2, 3, 4, 5, 6, 7-->
<!--					</span>-->
<!--				</pre>-->
<!--					<pre>-->
<!--					<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--						int maxValue = 10-->
<!--						int significantValue = 7-->

<!--						for (int i = 0 i < maxValue i++) {-->

<!--							if (i == significantValue) {-->
<!--								continue-->
<!--							}-->

<!--							System.out.println(i)-->
<!--						}-->
<!--					</code>-->
<!--					<span class="fragment fade-in">-->
<!--						1, 2, 3, 4, 5, 6, 8, 9-->
<!--					</span>-->
<!--				</pre>-->
<!--				</blockquote>-->
<!--			</section>-->
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Working with Strings</h2>
			</section>
			<section>
				<h3>Working with Strings</h3>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							/*
							 Printing to console
							 */
							println("Printing to console with new line at the end")
							print("Printing to console without new line at the end")
							println() // just new line

							/*
							 String concatenation using the + operator
							 */
							val name = "Moni"
							val hello = "Hello"

							val greeting = hello + " " + name + "!"
							println(greeting)

							/*
							 String interpolation
							 */
							val fullGreeting = "$hello $name"
							println(fullGreeting)

							/*
							 String concatenation using the += operator
							 */
							var greeting2 = "Hola"
							greeting2 += " $name!" // Assignment addition String concatenation
							println(greeting2)

							/*
							 String formatting
							 */
							val formattedGreeting = String.format("%s %s!", hello, name) // String formatting
							println(formattedGreeting)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Working with Strings</h3>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val text = "Banana, Apple, Orange, Kiwi, Mango, Pineapple, Watermelon, Strawberry"

							/*
							 Find the length of the text
							 */
							println("Length: " + text.length)

							/*
							 Split the text into an array of fruits
							 */
							val fruits = text.split(",".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
							for (fruit in fruits) {
								println(fruit.trim { it <= ' ' }) // trim to remove leading or trailing space
							}

							/*
							 Check if the text contains "Apple"
							 */
							println("Has apple: " + text.contains("Apple"))
							println(text.uppercase())
							println(text.lowercase())
							println(text.substring(10, 20))

							/*
							 Replace all occurrences of "Apple" with "Peach"
							 */
							val newText = text.replace("Apple", "Peach")
							println(newText)
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Functions</h2>
			</section>
			<section>
				<h3>Function</h3>
				<div class="summary">
					Kotlin is a modern language, supporting both traditional functions and object-oriented programming
					and functional programming paradigms.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<br />
							Functions are defined using the <code class="hljs inline">fun</code> keyword,
							followed by the function name, arguments, and return type.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun add(a: Int, b: Int): Int {
										return a + b
									}

									val sum = add(2, 3)
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<br />
							If the function does not return anything, the return type is <code class="hljs inline">Unit</code>,
							and does not need to be specified explicitly.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun greet(name: String) {
										println("Hello, $name!")
									}

									greet("Alice")
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<br />
							Functions can be written in a single expression, in which case the return type can be omitted.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun add(a: Int, b: Int) = a + b
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<br />
							Functions can be passed as arguments to other functions and returned from functions.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun operation(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
										return operation(a, b)
									}

									val sum = operation(2, 3) { a, b -> a + b }
								</code>
							</pre>
						</div>
					</div>
					<blockquote>
						Functions can be defined at the top level of a file, meaning they do not need to be part of a class.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Local functions</h3>
				<div class="summary">
					Functions can be defined inside other functions, in which case they are called local functions.
				</div>
				<div class="content">
					Defining a local functions is useful when you want to encapsulate some logic that is used multiple times
					but only within the function in which it is defined.
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							// outer function
							fun factorial(n: Int): Int {

								// local function
								fun fact(x: Int, acc: Int): Int {
									return if (x <= 1) acc else fact(x - 1, x * acc) // tail recursion
								}

								// calls the local function
								return fact(n, 1)
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							// main entry point with a call to the outer function
							fun main() {
								println(factorial(5)) // prints 120
							}
						</code>
					</pre>
				</div>
			</section>

			<section>
				<h3>Default arguments</h3>
				<div class="summary">
					Kotlin allows you to specify default values for function arguments, making them optional.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun round(
										value: Double,
										decimals: Int = 2 // argument with default value od 2
									): Double {
										val factor = 10.0.pow(decimals.toDouble())
										return (value * factor).roundToInt() / factor
									}
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Given a function with a default argument ...
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(3.14159)

									println(result) // prints 3.14
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							When the argument is not provided when calling the function, the default value is used.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(3.14159, 4)

									println(result) // prints 3.1416
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							When the argument is provided when calling the function, the provided value is used.
						</div>
					</div>
				</div>
			</section>

			<section>
				<h3>Named arguments</h3>
				<div class="summary">
					Kotlin allows you to specify the name of the arguments when calling a function.
				</div>
				<div class="content">
					<p>
						This is useful when you have a function with many arguments, and you want to make the code more readable,
						for example when you have a function with many arguments.
					</p>
					<p>
						It also allows you to specify arguments in any order, as long as you specify the name.
						This ofthe comes in handy when refactoring the code, adding or changing order of arguments.
					</p>

					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun round(
										value: Double,
										decimals: Int = 2
									): Double {
										val factor = 10.0.pow(decimals.toDouble())
										return (value * factor).roundToInt() / factor
									}
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Given function ...
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(value = 3.14159)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							You may specify the argument name.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val result = round(
										decimals = 4, // notice the changed order of arguments
										value = 3.14159
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							You may specify the argument names in any order.
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Named arguments</h3>
				<div class="content">
					A bigger example of using named arguments:
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									fun calculateEvapotranspiration(
										temperature: Double,
										solarRadiation: Double,
										humidity: Double,
										windSpeed: Double,
										atmosphericPressure: Double,
										location: Pair&lt;Double, Double&gt;,
										time: LocalDateTime,
										soilType: SoilType,
										cropType: CropType
									): Double {
										// calculation
									}
								</code>
							</pre>
						</div>
						<div class="column">
							Without argument names ...
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									calculateEvapotranspiration(
										25.0,
										800.0,
										0.6,
										3.0,
										1013.25,
										13.7655756 to 100.5675686,
										LocalDateTime.now(),
										SoilType.CLAY,
										CropType.WHEAT,
									)
								</code>
							</pre>
							With argument names ...
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									calculateEvapotranspiration(
										soilType = SoilType.CLAY,
										cropType = CropType.WHEAT,
										time = LocalDateTime.now(),
										location = 13.7655756 to 100.5675686,
										temperature = 25.0,
										solarRadiation = 800.0,
										humidity = 0.6,
										windSpeed = 3.0,
										atmosphericPressure = 1013.25
									)
								</code>
							</pre>
						</div>
					</div>

			</section>
			<section>
				<h3>Variable Arguments</h3>
				<div class="summary">
					Variadic functions are functions that can take a variable number of arguments.
				</div>
				<div class="content">
					<p>
						You can define a function that takes a variable number of arguments by using the <code class="inline">vararg</code> keyword.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun sayHello(vararg names: String): Int {
								println("Hello, ${names.joinToString(", ")}!")
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun main() {
								sayHello("Alice", "Bob", "Charlie") // prints "Hello, Alice, Bob, Charlie!"
							}
						</code>
					</pre>
					<p>
						If you need more than one argument, the <code class="inline">vararg</code> argument must be the last one.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun sayHello(greeting: String, vararg numbers: Int): Int {
								println("Hello, ${names.joinToString(", ")}!")
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun main() {
								sayHello(greeting = "Hi", "Alice", "Bob", "Charlie") // prints "Hi, Alice, Bob, Charlie!"
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Objects and Classes</h2>
			</section>
			<section>
				<h3>Objects and Classes</h3>
				<div class="summary">
					We have already seen and worked with Kotlin objects and classes.
					<br />
					Let's explain what they are and how they work in more detail.
				</div>
				<div class="content content-center">
					<br />
					<div>
						<div class="highlight" style="font-size: larger; font-weight: bolder">What is an object?</div><br />
						<div style="font-size: larger; font-style: italic" class="fragment fade-in">Object is a data structure in memory<br /></div>
					</div>
					<br />
					<br />
					<div>
						<div class="highlight" style="font-size: larger; font-weight: bolder">What is a class?</div><br />
						<div style="font-size: larger; font-style: italic" class="fragment fade-in">Class is a template for how to create an object</div>
					</div>
					<br />
					<blockquote class="fragment fade-in">
						Think of a class as a blueprint for creating objects.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Class Definition</h3>
				<div class="summary">
					Class is defined using the <code class="hljs inline">class</code> keyword, followed by the class name,
					class header and the class body.
				</div>
				<div class="content">
					<ul>
						<li>
							<span class="highlight">Class name</span> -
							should begin with an initial letter (capitalized by convention).
						</li>
						<li>
							<span class="highlight">Class header</span> -
							class type parameters, the primary constructor, and other things, such as its superclass or interfaces it implements.
						</li>
						<li>
							<span class="highlight">Class properties</span> -
							are defined in the class header and are used to hold the state of the class and its objects.
						</li>
						<li>
							<span class="highlight">Class body</span> -
							containing fields, methods, constructors, initializer blocks, inner classes, and interfaces enclosed in curly braces.
							<ul>
								<li>
									<span class="highlight">Fields</span> -
									additional properties that hold the state of the class and its objects.
								</li>
								<li>
									<span class="highlight">Methods</span> -
									functions that are part of the class and contain the executable code.
								</li>
								<li>
									<span class="highlight">Constructors</span> -
									special methods used to initialize the state of an object.
								</li>
								<li>
									<span class="highlight">Initializer blocks</span> -
									unnamed code blocks used for initializing shared variables and executing code that needs to run every time an instance of the class is created.
								</li>
								<li>
									<span class="highlight">Inner classes and interfaces</span> -
									class or interface definitions nested within the outer class body.
								</li>
								<li>
									<span class="highlight">Companion objects</span> -
									special objects that are tied to a class, rather than to an instance of a class.
								</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Class Definition</h3>
				<div class="summary">
					Class is defined using the <code class="hljs inline">class</code> keyword, followed by the class name,
					class header (optional), and the class body (optional) enclosed in curly braces.
				</div>
				<div class="content">
					<div>
						Simple class definition without body.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								class UniversityCourse
							</code>
						</pre>
					</div>
					<div>
						More realistic class definition with parameters and body.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								class UniversityCourse(
									val subject: String,
									val startDate: LocalDate,
									val endDate: LocalDate,
									val students: MutableList&lt;String&gt; = mutableListOf() // initial value of empty list
								) {

									// class field which is not part of the constructor
									private var isOpen: Boolean = false // initial value of false

									fun addStudent(studentName: String) {
										if (isOpen) {
											students.add(studentName)
										} else {
											error("Cannot add students to closed course.")
										}
									}

									fun open() {
										isOpen = true
									}

									fun close() {
										isOpen = false
									}
								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h3>Class Instantiation</h3>
				<div class="summary">
					You do not directly work with classes in Kotlin, you work with objects that are created from classes, called class instances.
				</div>
				<blockquote>
					Object == Instance of a class
				</blockquote>
				<div class="content">
					<ul>
						<li>The process that creates an object from class is called <strong>instantiation</strong></li>
						<li>Instantiation is done by calling a special <strong>constructor</strong> method</li>
						<li>Class may have <strong>one or more</strong> constructors</li>
						<li>If constructor is not explicitly defined, then the class will <strong>default constructor with no arguments</strong></li>
						<li>Instantiation can be used to set initial values for the object</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Class Header</h3>
				<div class="summary">
					Class header defines its type parameters, the primary constructor, and other things,
					such it's superclass or interfaces it implements.
				</div>
				<div class="content">
					<div>
						<ul>
							<li>The class header specifies class properties (fields).</li>
							<li>Just like functions argument, class fields can have default values.</li>
							<li>The declared fields also define the class primary constructor.</li>
							<li>
								In this example, the class header specifies that the class has four fields, one with a default value,
								which means that it can be omitted when creating an instance of the class.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class UniversityCourse(
											val subject: String,
											val startDate: LocalDate,
											val endDate: LocalDate,
											val students: MutableList&lt;String&gt; = mutableListOf() // initial value of empty list
										) {
											// class body
										}
									</code>
								</pre>
							</li>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<h3>Class Constructors</h3>
				<div class="summary">
					Class constructor is a special method with the only purpose of class instantiation.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							Class with zero arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class KotlinCourse {
										val subject: String = "Kotlin"
									}


									val kotlinCourse = KotlinCourse()
								</code>
							</pre>
							Class with one arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class Course(val subject: String)


									val kotlinCourse = Course("Kotlin")
								</code>
							</pre>
						</div>
						<div class="column">
							Class with multiple arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class Course(
										val subject: String,
										val startDate: LocalDate,
										val endDate: LocalDate
									)


									val kotlinCourse = Course(
										"Kotlin",
										LocalDate.parse("2024-02-03"),
										LocalDate.parse("2024-02-21")
									)
								</code>
							</pre>
						</div>
					</div>
					<ul>
						<li>Every class has a constructor, even if it is not explicitly defined.</li>
						<li>Class may have multiple constructors (primary and secondary constructors).</li>
						<li>Constructor may have zero, one, or many arguments</li>
						<li>Class constructors support named arguments just like functions.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Alternate class constructors</h3>
				<div class="summary">
					Kotlin allows you to define multiple constructors for a class, also called secondary constructors.
					They provide alternative ways to instantiate the class.
				</div>
				<div class="content">
					Example of class definition, class alternate constructor, and constructor calls.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							// primary constructor defined by class header
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate
							) {

								// alternate constructor
								constructor(
									subject: String,
									startDate: String,
									endDate: String,
								) : this(subject, LocalDate.parse(startDate), LocalDate.parse(endDate))
							}
						</code>
					</pre>
					Primary constructor call with default values
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse1 = UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"), LocalDate.parse("2024-02-21"))
						</code>
					</pre>
					Alternate constructor call
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse3 = UniversityCourse("Kotlin", "2024-02-03", "2024-02-21")
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Default values & Named arguments</h3>
				<div class="summary">
					Just like functions, class constructors can have default values and support named arguments.
				</div>
				<div class="content">
					Class constructor really is just a special kind of function, so just like functions,
					class constructors can have default values and support named arguments.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),    // default date
								val students: MutableList&lt;String&gt; = mutableListOf() // default value of empty list
							) {
								// class body
							}
						</code>
					</pre>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"))
								</code>
							</pre>
						</div>
						<div class="column"><br />Calling the constructor with default values.</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse(
										"Kotlin",
										LocalDate.parse("2024-02-03"),
										students = mutableListOf("Alice", "Bob")
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Calling the constructor with one named argument for <strong>students</strong>.
							<br />
							The <strong>endDate</strong> will be set to the default value.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse(
										subject = "Kotlin",
										startDate = LocalDate.parse("2024-02-03"),
										endDate = LocalDate.parse("2024-02-21"),
										students = mutableListOf("Alice", "Bob")
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Naming all arguments when calling the constructor.
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Methods</h3>
				<div class="summary">
					Method is a function associated with an object.<br />
					In Kotlin, you can also call methods member functions.
				</div>
				<div class="content">
					<p>
						Same rules and possibilities apply to methods as to functions not associated with a class.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							) {

								fun addStudent(studentName: String) {
									students.add(studentName)
								}

								fun removeStudent(studentName: String) {
									students.remove(studentName)
								}

								fun printStudents() {
									students.forEach { println(it) }
								}
							}
						</code>
					</pre>
					<p>
						The only difference is that methods are called on an instance of object.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse = UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"))
							kotlinCourse.addStudent("Alice")
							kotlinCourse.addStudent("Bob")
							kotlinCourse.printStudents()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Initializer blocks</h3>
				<div class="summary">
					Initializer blocks are code that is run when an instance of a class is created.
				</div>
				<div class="content">
					<p>
						For example, this can be used for additional argument validation or to set up some initial state.
					</p>
					<p>
						Class may have one or more initializer blocks, which are executed in the order they are defined.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							) {

								init {
									require(startDate < endDate) { "End date must be after start date" }
								}

								init {
									println("Course $subject created")
								}

							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Scope and "this" reference</h3>
				<div class="summary">
					In Kotlin, the <code class="inline">this</code> keyword is used to refer to the current instance of a class.
				</div>
				<div class="content">
					It is often used to distinguish between class properties and parameters or local variables with the same name.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class Person(val name: String) {

								fun introduce(name: String) {
									println("${this.name} also goes by $name")
								}

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val person = Person("Monika")
								person.introduce("Moni") // prints "Monika also goes by Moni"
							}
						</code>
					</pre>
					Additionally, Kotlin provides other scope references using <code class="inline">@label</code> to refer to specific instances in nested scopes.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class A {
								inner class B {
									fun Int.foo() {
										val a = this@A // refers to the instance of A
										val b = this@B // refers to the instance of B
										val c = this // refers to the receiver Int
										println("a: $a, b: $b, c: $c")
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val a = A()
								val b = a.B()
								b.run { 42.foo() }
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Class destruction</h3>
				<div class="summary">
					Java/Kotlin has no class destructor, because freeing up memory is entirely delegated to JVM through
					a process called <strong>garbage collection</strong>, which we will talk about in later in the course.
				</div>
				<div class="content">
					Some Java/Kotlin classes may have a special methods that should be called after we are done using
					the class in order for it to be eligible for garbage collection. I will also mention these
					later in the course.
				</div>
			</section>
			<section>
				<h3>Inner classes</h3>
				<div class="summary">
					Inner class (also called nested class), is a class defined within a body of another class.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class OuterClass {

								private val outerField: String = "Outer Field"

								// Inner class
								inner class InnerClass {
									fun accessOuterField(): String {
										return outerField
									}
								}
							}
							</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val outer = OuterClass()
								val inner = outer.InnerClass()
								println(inner.accessOuterField()) // prints "Outer Field"
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Use case for nested classes</h3>
				<div class="content">
					<br />
					<h4>Logical Grouping</h4>
					<div>
						Nested classes can help us keep our code organized by having related code together.
						For example, you may want to create an internal data class.
					</div>
					<br />
					<br />
					<!--						</li>-->
					<!--					<li>-->
					<!--						<strong>Access Control</strong>-->
					<!--						<div>-->
					<!--							Inner classes can access members of the outer class, including those marked as private.-->
					<!--							This feature is helpful when you need to create a helper class that needs access to an outer-->
					<!--							class’s fields or methods.-->
					<!--						</div>-->
					<!--					</li>-->
					<!--						<li>-->
					<h4>Encapsulation & Access Control</h4>
					<div>
						Inner classes can access members of the outer class, including those marked as private.
						This can benefit us in multiple scenarios, such us when creating helper classes without exposing
						private methods or fields of the outer class.
						<!--							Consider two top-level classes, A and B, where B needs access to the private members of A.-->
						<!--							We could change the visibility of A's members from private to protected or public to allow B access.-->
						<!--							However, this would also provide access to all other classes which is sometimes not desirable.-->
					</div>
					<br />
					<br />
					<h4>Increased Readability and Maintainability</h4>
					<div>
						Inner classes are used for code that is relevant to a small part of the outer class.
						Grouping them together improves code readability and maintainability.
					</div>
				</div>
			</section>
			<section>
				<h3>Anonymous Classes</h3>
				<div class="summary">
					<!--					Anonymous class is a class which does not have a name.-->
					In Kotlin, anonymous classes are a way to create an instance of a class with certain modifications
					without having to actually declare a new subclass. They are often used to create instances
					of classes that have no name and are used only once.
				</div>
				<!--				<p>-->
				<!--					In Java, an anonymous class is an inner class (a class within another class), which does not have a name.-->
				<!--					Since it has no name, we have no way to instantiate such class. Thus, an anonymous class must be declared and instantiated with a single expression.-->
				<!--				</p>-->
				<div class="content">
					<p>
						Since it has no name, we have no way to instantiate such class.<br />
						Thus, an anonymous class must be declared and instantiated with a single expression.
					</p>
					<p>
						An anonymous class must either implement an interface or extend an existing class (abstract or concrete).
					</p>
					<p>
						<!--						Anonymous classes are helpful when we wish to use a local class only once, but their use is-->
						<!--						generally discouraged in favour of Lambda expression (which I'll explain shortly).-->
						Anonymous classes are useful for creating quick, one-off implementations of interfaces or abstract classes.
					</p>
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						fun main() {

							val runnable = object : Runnable {
								override fun run() {
									println("Running in an anonymous class!")
								}
							}

							val thread = Thread(runnable)

							thread.start()
						}
					</code>
				</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Singleton Objects</h2>
				<em>Static classes and constants in Kotlin</em>
			</section>
			<section>
				<h3>Singleton Objects</h3>
				<div class="summary">
					Singleton object is a class that can have only one instance in memory.
				</div>
				<div class="content">
					<p>
						In Java and other languages, we used so called singleton pattern to create a class that can have only one instance.
					</p>
					<p>
						Kotlin provides a convenient way to create singleton objects using the <code class="inline">object</code> keyword.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							object StringUtils {

								val DECIMAL_PLACES = 2

								fun formatNumber(number: Double): String {
									// code to format number
								}

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val formattedNumber = StringUtils.formatNumber(3.14159)
								println(formattedNumber) // prints "3.14"
							}
						</code>
					</pre>
					<h4>Some key features:</h4>
					<ul>
						<li><strong>Singleton</strong> - Only one instance of the object is created.</li>
						<li><strong>Utility Methods</strong> - Commonly used for utility methods and constants.</li>
						<li><strong>Initialization</strong> - The object is initialized when it is first accessed.</li>
						<li><strong>No Constructors</strong> - Objects cannot have constructors.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Use case for static objects</h3>
				<div class="content">
					<h4>Utility or Helper Classes</h4>
					<p>
						Sometimes we need some methods to be globally available in the application without needing to create class instance every time.
						Example of such is utility classs with static methods is <code class="inline">String.valueOf()</code>
						or <code class="inline">Integer.toBinaryString()</code>.
					</p>
					<br />
					<h4>Global Constants and Variables</h4>
					<p>
						Static keyword can be used to define class level variables hat are accessible throughout our application.
					</p>
					<br />
					<h4>Singleton Pattern</h4>
					<p>
						Kotlin object is equivalent to Java's singleton pattern, but with the convenience of a simpler, error-proof syntax.
						Singleton class is a design pattern that restricts the instantiation of a class to a single instance.
					</p>
				</div>
			</section>
			<section>
				<h3>Companion Objects</h3>
				<div class="summary">
					Companion object is an object that is tied to a class, rather than to an instance of a class.
				</div>
				<div class="content">
					<ul>
						<li>There can be only one companion object per class, and it is defined using the <code class="inline">companion</code> keyword.</li>
						<li>It may have a name, but it is optional. Otherwise, it is referred to as a default companion object.</li>
						<li>It is often used to define static methods and constants.</li>
						<li>Other than that, it is just like any other object.</li>
						<li>Companion objects are by convention placed at the bottom of the class.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate
							) {

								// regular class methods

								companion object UniversityCourseFactory { // companion object name is optional
									const val KOTLIN = "Kotlin"

									fun kotlinCourse(startDate: String, endDate: String): UniversityCourse {
										return UniversityCourse(KOTLIN, LocalDate.parse(startDate), LocalDate.parse(endDate))
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {

								val kotlinCourse = UniversityCourse.kotlinCourse("2024-02-03", "2024-02-21")

								println(UniversityCourse.KOTLIN) // prints "Kotlin"

							}
						</code>
					</pre>
				</div>
			</section>
		</section>



		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Collections</h2>
			</section>
			<section>
				<h3>Collections</h3>
				<div class="summary">
					Collections are similar to arrays, but they are more flexible and have more features at the cost
					of being less efficient in terms of memory and performance.
				</div>
				<div class="content">
					<p>
						The main difference between arrays and collections is that collections can grow or shrink in size.
						They generally provide more functionality and are easier to work with than arrays, but also
						are less efficient in terms of memory and performance.
					</p>
					<p>
						There are several types of collections in Kotlin, such as <code>List</code>, <code>Set</code>, <code>Map</code>, etc.
					</p>
					<p>
						Unlike and array, which is basic data structure, collections are interfaces that define a set of operations that can be performed on a group of objects.
					</p>
					<p>
						<em>We will learn in detail about collections in the future lesson.</em>
					</p>
				</div>
			</section>
			<section>
				<h3>Collections</h3>
				<div class="summary">
					Collection is a group of <span class="highlight">variable number</span> of objects of the same type (and its subtypes).
				</div>
				<div class="content">
					<div>
						<p>
							The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps.
							A pair of interfaces represent each collection type:
						</p>
					</div>
					<div class="row">
						<div class="column">
							<ul>
								<li>
									<span class="highlight">read-only interface</span>
									<br />
									provides operations for accessing collection elements.
								</li>
								<li>
									<span class="highlight">mutable interface</span>
									<br />
									extends the corresponding read-only interface with write operations: adding, removing, and updating its elements.
								</li>
							</ul>
							<p>
								See Kotlin <a href="https://kotlinlang.org/docs/collections-overview.html#collection-types">documentation</a> for more details.
							</p>
						</div>
						<div class="column">
							<img src="./img/collections-diagram.png" style="padding-left: 20px"/>
						</div>
					</div>
				</div>
			</section>

			<section>
				<h3>Collections</h3>
				<div class="summary">
					There are 3 main types of collections in Kotlin: lists, sets, and maps.
				</div>
				<div class="content">
					<h4>Lists</h4>
					<p>
						Lists are <strong>ordered</strong> collections of elements that <strong>can contain duplicates</strong> and individual elements can be accessed by their index.
					</p>
					<h4>Sets</h4>
					<p>
						Sets are <strong>unordered</strong> collections of unique elements, meaning order is not guaranteed, and they <strong>don't allow duplicate elements</strong>.
					</p>
					<p>
						You can work with a set just like you would with a list, but there are some differences:
					</p>
					<ul>
						<li>You cannot access elements by index, because sets are unordered.</li>
						<li>Adding an element that already exists in the set will not add a duplicate.</li>
						<li>Removing an element that does not exist in the set will not throw an exception.</li>
					</ul>
					<br />
					<br />
					<h4>Maps</h4>
					<p>
						Maps are collections of <strong>key-value pairs</strong>, where <strong>keys are unique</strong> and are used to access values. Values can be duplicates.
					</p>
					<p>
						<em>
							Kotlin provides standard library functions for working with collections, which we will explore in more detail.
						</em>
					</p>
				</div>
			</section>
			<section>
				<h3>Constructing Collections</h3>
				<div class="summary">
					There are standard library functions for constructing collections in Kotlin for both read-only and mutable collections.
				</div>
				<div class="content">
					<p>
						Collections are constructed using functions <code class="inline">listOf&lt;Type&gt;()</code>,
						<code class="inline">setOf&lt;Type&gt;()</code>
						or <code class="inline">mapOf&lt;KeyType, ValueType&gt;()</code> for read-only collections.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf&lt;String&gt;()

							val set = setOf&lt;Int&gt;()

							val map = mapOf&lt;String, Int&gt;()
						</code>
					</pre>
					<p>
						Or by variable type declaration.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list: List&lt;String&gt; = listOf()
						</code>
					</pre>
					<p>
						If type can be inferred from the elements, you can omit the type declaration.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val set = setOf(2020, 2021, 2022, 2023, 2024, 2025)

							val map = mapOf(
								"Java" to 1995,
								"Kotlin" to 2011,
								"JavaScript" to 1995,
								"TypeScript" to 2012,
								"Python" to 1991
							)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Constructing Collections</h3>
				<div class="summary">
					There are standard library functions for constructing collections in Kotlin for both read-only and mutable collections.
				</div>
				<div class="content">
					<p>
						Mutable collections can be created using <code class="inline">mutableListOf&lt;Type&gt;()</code>,
						<code class="inline">mutableSetOf&lt;Type&gt;()</code>
						and <code class="inline">mutableMapOf&lt;KeyType, ValueType&gt;()</code>.
					</p>
					<p>
						To construct an empty collection, you can use the <code class="inline">emptyList&lt;Type&gt;()</code>,
						<code class="inline">emptySet&lt;Type&gt;()</code>
						or <code class="inline">emptyMap&lt;KeyType, ValueType&gt;()</code> functions.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val emptyList = emptyList&lt;String&gt;()

							val emptySet = emptySet&lt;Int&gt;()

							val emptyMap = emptyMap&lt;String, Int&gt;()
						</code>
					</pre>
					<p>
						Similarly, empty collections can be created <code class="inline">emptyMutableList&lt;Type&gt;()</code>,
						<code class="inline">emptyMutableSet&lt;Type&gt;()</code>
						and <code class="inline">emptyMutableMap&lt;KeyType, ValueType&gt;()</code> functions.
					</p>
				</div>
			</section>
			<section>
				<h3>Arrays vs. Collections</h3>
				<div class="summary">
					Both arrays and Collections are used to store data. <br />
					There are however some notable differences that make them suitable for different use cases.
				</div>
				<div class="content">
					<table>
						<thead>
						<tr style="font-weight: bold">
							<td></td>
							<td>Arrays</td>
							<td>Collections</td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td style="font-weight: bold">Size</td>
							<td>Arrays have fixed size. This may lead to memory wastage, but is also inconvenient to work with.</td>
							<td>Collections can grow or shrink dynamically to accommodate the data.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Type Safety</td>
							<td>Arrays are type-safe</td>
							<td>Collections are type-safe (through generic typing)</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Performance</td>
							<td>Arrays can perform better than collections for some operations because of their simpler memory layout, lower overhead, and ability to employ direct indexing.</td>
							<td>Collections have more overhead than arrays, and certain operations may be slower as a result. However, the built-in utilities in collections make them more convenient for complex data manipulation.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Functionality</td>
							<td>Arrays offer basic functionality such as adding elements, getting elements, and modifying existing elements.</td>
							<td>
								Collections provide a wide variety of functionalities.
								They can be sorted, reversed, shuffled. They support operations like addition, inspection, modification, deletion, searching and other.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Use Cases</td>
							<td>Arrays are best for fixed-size collections where performance is critical.</td>
							<td>Collections are best for dynamic collections with rich functionality and advanced operations.</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Collections: Kotlin vs. Java</h3>
				<div class="summary">
					Collections in Kotlin are actually one of the most significant differences between Kotlin and Java,
					because they are implemented differently in Kotlin.
				</div>
				<div class="content">
					<table>
						<thead>
						<tr>
							<td style="font-weight: bold"></td>
							<td style="font-weight: bold">Java</td>
							<td style="font-weight: bold">Kotlin</td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td style="font-weight: bold">Null Safety</td>
							<td>Collections can contain null values unless explicitly handled.</td>
							<td>Collections are null-safe by default. You can explicitly declare nullable collections if needed.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Read-Only vs Mutable</td>
							<td>Collections are mutable by default. Read-only views can be created using utility methods.</td>
							<td>Distinguishes between read-only (List, Set, Map) and mutable (MutableList, MutableSet, MutableMap) collections.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Higher-Order Functions</td>
							<td>Introduced lambda expressions and streams in Java 8, but the syntax is more verbose compared to Kotlin.</td>
							<td>Supports higher-order functions and lambda expressions, making it easier to perform operations like filtering, mapping, and reducing.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Default Implementations</td>
							<td>Requires more boilerplate code for common operations.</td>
							<td>Provides default implementations for many collection operations, making the code more concise.</td>
						</tr>
						</tbody>
					</table>
					<blockquote>
						Note that because Java and Kotlin are fully interoperable,
						you can opt to use Java implementations of collections in Kotlin, if needed.
					</blockquote>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Operations</h2>
			</section>
			<section>
				<h3>Operations</h3>
				<div class="summary">
					The Kotlin standard library provides a rich set of functions for working with collections.
				</div>
				<div class="content">
					<p>
						Collection operations are declared in the standard library in two ways:
					</p>
					<ol>
						<li>
							<strong class="highlight">Member functions of collection interfaces</strong>
							<em>defining operations that are essential for the collection type.</em>
						</li>
						<li>
							<strong class="highlight">Extension functions</strong>
							<em>providing additional functionality.</em>
						</li>
					</ol>
					<p>
						This is important to know in case you want to implement you own collection type as you will need
						to implement all functions in the given interface(s).
					</p>
					<p>
						Some of the common operations on collections include:
					</p>
					<ul>
						<li>Transformations</li>
						<li>Filtering</li>
						<li>plus and minus operators</li>
						<li>Grouping</li>
						<li>Retrieving collection parts</li>
						<li>Retrieving single elements</li>
						<li>Ordering</li>
						<li>Aggregate operations</li>
					</ul>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Adding, Removing and Retrieving Elements</h2>
			</section>
			<section>
				<h3>Adding Elements</h3>
				<div class="content">
					<p>
						For immutable collections, you can use the <code class="inline">plus()</code> function to create a new collection with the added element.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript")

							list.plus("Python")
						</code>
					</pre>
					<p>
						For mutable collections, you can use the <code class="inline">add()</code>,
						<code class="inline">addFirst()</code>, <code class="inline">addLast()</code>
						and <code class="inline">addAll()</code>functions to add an elements to the collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val mutableList = mutableListOf("Java", "Kotlin")

							mutableList.add("C#")
							mutableList.addLast("Rust")
							mutableList.addAll(listOf("JavaScript", "TypeScript"))
						</code>
					</pre>

					<p>
						For both mutable and immutable collections, you can use the <code class="inline">+</code> operator to create a new collection with the added element.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val newList = list + "Python"
						</code>
					</pre>
					<p>
						You can also add elements to mutable collections using the <code class="inline">+=</code> operator.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							mutableList += "Python"
						</code>
					</pre>
					<p>
						And finally, you can use the <code class="inline">addAll()</code>,
						<code class="inline">addFirst()</code>, and <code class="inline">addLast()</code> functions to add multiple elements to a mutable collection.
					</p>
				</div>
			</section>
			<section>
				<h3>Removing Elements</h3>
				<div class="content">
					<p>
						Removing elements is similar.
					</p>
					<p>
						Immutable collections provide the
						<code class="inline">minus()</code> function and the
						<code class="inline">-</code> operator to create a new collection with the removed element.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val newList = list - "JavaScript"
						</code>
					</pre>
					<p>
						Mutable collections provide the
						<code class="inline">remove()</code>,
						<code class="inline">removeFirst()</code>,
						<code class="inline">removeLast()</code>
						<code class="inline">removeAt()</code>,
						<code class="inline">removeAll()</code>
						and also <code class="inline">removeIf()</code> functions to remove an element from the collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val mutableList = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							// removes element "JavaScript"
							mutableList.remove("JavaScript")

							// removes element at index 2
							mutableList.removeAt(2)

							// removes elements "Java" and "Kotlin"
							mutableList.removeAll(listOf("Java", "Kotlin"))

							// removes elements with length > 5
							mutableList.removeIf { it.length > 5 }
						</code>
					</pre>
					<p>
						You can also use the <code class="inline">-=</code> operator to remove an element from a mutable collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							mutableList -= "JavaScript"
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Retrieving Elements</h3>
				<div class="content">
					<p>
						Retrieving elements from a collection is straightforward and similar to arrays.
					</p>
					<p>
						Here are few examples:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							// get element at index 2
							val element = list[2]

							// get first element
							val first = list.first()

							// get last element
							val last = list.last()

							// get element at index 2 or return "C++" if index is out of bounds
							val elementAtOrElse = list.getOrElse(2) { "C++" }

							// get element at index 10 or return null if index is out of bounds
							val elementAtOrNull = list.getOrNull(10)

							// you can also use the random() function to get a random element from the collection
							val randomElement = list.random()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<div>
					<h3>Retrieving collection parts</h3>
					<div class="content">
						<p>
							You are not limited to retrieving single elements from a collection. You can also retrieve parts of a collection, or slices.
						</p>
						<p>
							These are some of the functions available in the Kotlin SDK:
						</p>
						<ul>
							<li><code class="inline">slice</code> - returns a list of elements at the specified indices.</li>
							<li><code class="inline">take</code> - returns a list of the first n elements.</li>
							<li><code class="inline">takeLast</code> - returns a list of the last n elements.</li>
							<li><code class="inline">takeWhile</code> - returns a list of elements that match the predicate.</li>
							<li><code class="inline">drop</code> - returns a list of elements after the first n elements.</li>
							<li><code class="inline">dropLast</code> - returns a list of elements before the last n elements.</li>
							<li><code class="inline">dropWhile</code> - returns a list of elements after the first element that does not match the predicate.</li>
						</ul>
					</div>
				</div>
			</section>
			<!--			<section>-->
			<!--				<h3>Exercise</h3>-->
			<!--				<div class="content">-->
			<!--				</div>-->
			<!--			</section>-->
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Traversing Collections</h2>
			</section>
			<section>
				<h3>Iterators</h3>
				<div class="summary">
					Kotlin provides standard library functions for traversing collections using iterators.
				</div>
				<div class="content">
					<p>
						Iterators can be obtained for collections that implement the <code class="inline">Iterable</code> interface
						by calling the <code class="inline">iterator()</code> function.
						<br />
						Once you have an iterator, you can traverse the collection using the <code class="inline">next()</code>
						and <code class="inline">hasNext()</code> functions.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val iterator = list.iterator()

							while (iterator.hasNext()) {
								println(iterator.next())
							}
						</code>
					</pre>
					<p>
						For List, there is a <code class="inline">ListIterator</code>, which allows traversing the list in reverse order
						by using the <code class="inline">previous()</code> function.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							while (listIterator.hasPrevious()) {
								println(listIterator.previous())
							}
						</code>
					</pre>
					<p>
						For mutable collections, you can use the <code class="inline">MutableIterator</code>,
						which provides a <code class="inline">remove()</code> function to remove elements from the collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val mutableList = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val iterator = mutableList.iterator()

							while (iterator.hasNext()) {
								val element = iterator.next()
								if (element == "JavaScript") {
									iterator.remove()
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>For Loop</h3>
				<div class="summary">
					You can use a <code class="inline">for</code> loop to iterate over collections that implement
					the <code class="inline">Iterable</code> interface <br />(or its subtypes).
				</div>
				<div class="content">
					<p>
						Iterators are not the most idiomatic way to iterate over collections,
						so Kotlin provides other ways to iterate over collections which implement the <code class="inline">Iterable</code> interface.
					</p>
					<p>
						One of such ways is to use a <code class="inline">for</code> loop.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							for (element in list) {
								println(element)
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>The forEach Function</h3>
				<div class="summary">
					Another way to iterate over collections is to use the <code class="inline">forEach</code> function.
				</div>
				<div class="content">
					<p>
						The <code class="inline">forEach</code> function is a higher-order function that takes a lambda as an argument.
						The basic syntax is ...
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							list.forEach {
								println(it)
							}
						</code>
					</pre>
					<p>
						By default, the lambda passed to the <code class="inline">forEach</code> function takes a single argument,
						which can be referenced using the <code class="inline">it</code> keyword.
					</p>
					<p>
						You can also specify the argument name explicitly (in this case, <code class="inline">element</code>).
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							list.forEach { element ->
								println(element)
							}
						</code>
					</pre>
					<p>
						There is also a shorthand syntax for the lambda if it takes a single argument.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							list.forEach(::println)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>The forEachIndexed Function</h3>
				<div class="summary">
					You can use the <code class="inline">forEachIndexed</code> function to iterate over collections with index.
				</div>
				<div class="content">
					<p>
						The <code class="inline">forEachIndexed</code> function is similar to the <code class="inline">forEach</code> function,
						but it also provides the index of the element as the first argument to the lambda. This may be useful in some situations.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							list.forEachIndexed { index, element ->
								println("Element at index $index is $element")
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Collection Transformations</h2>
			</section>
			<section>
				<h3>Collection Transformations</h3>
				<div class="summary">
					There are many operations that can be performed on collections to transform them in some way which are
					part of the Kotlin SDK.
				</div>
				<div class="content">
					<p>
						Some common transformation operations performed on collections include:
					</p>
					<ul>
						<li>
							<strong class="highlight">map</strong>
							using functions like
							<code class="inline">map</code>,
							<code class="inline">flatMap</code>,
							<code class="inline">mapNotNull</code>,
							<code class="inline">mapIndexed</code>,
							<code class="inline">mapIndexedNotNull</code>.
						</li>
						<li>
							<strong class="highlight">filter</strong>
							using functions like
							<code class="inline">filter</code>,
							<code class="inline">filterNot</code>,
							<code class="inline">filterIndexed</code>,
							<code class="inline">filterNotNull</code>,
							<code class="inline">distinct</code>,
							<code class="inline">distinctBy</code>.
						</li>
						<li>
							<strong class="highlight">sort</strong>
							using functions like
							<code class="inline">sorted</code>,
							<code class="inline">sortedBy</code>,
							<code class="inline">sortedWith</code>,
							<code class="inline">sortedDescending</code>,
							<code class="inline">sortedByDescending</code>,
							<code class="inline">reversed</code>,
							<code class="inline">shuffled</code>.
						</li>
						<li>
							<strong class="highlight">group</strong>
							using functions like
							<code class="inline">groupBy</code>,
							<code class="inline">partition</code>,
							<code class="inline">associate</code>,
							<code class="inline">associateBy</code>,
							<code class="inline">associateWith</code>.
						</li>
						<li>
							<strong class="highlight">plus, minus</strong>
							to add or remove elements from a collection.
						</li>
						<li>
							<strong class="highlight">other transformation</strong>
							functions like
							<code class="inline">reduce</code>,
							<code class="inline">zip</code>,
							<code class="inline">zipWithNext</code>,
							<code class="inline">unzip</code>,
							<code class="inline">flatten</code>,
							<code class="inline">fold</code>.
						</li>
					</ul>
					<p>
						All of these transformations return a new collection with the transformation applied,
						they do not modify the original collection.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Mapping Functions</h2>
			</section>
			<section>
				<h3>mapping functions</h3>
				<div class="summary">
					<code class="inline">map</code> is a transformation operation that applies a function to each element in the collection
					and returns a new collection with the results.
				</div>
				<div class="content">
					<p>
						The returned collection can be of any type, not necessarily the same as the original collection.
					</p>
					<p>
						There are several map functions available in the Kotlin standard library:
					</p>
					<ul>
						<li>
							<code class="inline">map</code>
							- applies a function to each element and returns a list of the results.
						</li>
						<li>
							<code class="inline">mapNotNull</code>
							- applies a function to each element and returns a list of non-null results.
						</li>
						<li>
							<code class="inline">mapIndexed</code>
							- applies a function to each element and its index and returns a list of the results.
						</li>
						<li>
							<code class="inline">mapIndexedNotNull</code>
							- applies a function to each element and its index and returns a list of non-null results.
						</li>
						<li>
							<code class="inline">flatMap</code>
							- applies a function to each element and returns a list of the results, which are then flattened into a single list.
						</li>
						<li>
							<code class="inline">mapTo, mapIndexedTo, mapNotNullTo, etc ... </code>
							- applies a function to each element and adds the results to the given destination.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Exercise #1</h3>
				<div class="content">
					<p>
						Assume you have two lists containig character names. Each list contains characters form different fractions.
						<br />
						For example:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val jediNames = listOf("Luke Skywalker", "Yoda", "Obi-Wan Kenobi", "Mace Windu", "Qui-Gon Jinn")
							val sithNames = listOf("Darth Vader", "Emperor Palpatine", "Darth Maul", "Kylo Ren", "Count Dooku")
							val rebelNames = listOf("Leia Organa", "Han Solo", "Chewbacca", "C3PO", "R2D2")
							val imperialNames = listOf("Stormtrooper", "Imperial Officer", "Imperial Guard", "Death Trooper", "TIE Fighter Pilot")
						</code>
					</pre>
					<p>
						Create the following classes:
					</p>
					<ol>
						<li>
							<code class="inline">StarWarsCharacter</code> with properties <code class="inline">name: String</code> and <code class="inline">fraction: Fraction</code>.
						</li>
						<li>
							<code class="inline">Fraction</code> enum with values
							<code class="inline">JEDI</code>,
							<code class="inline">SITH</code>,
							<code class="inline">REBEL</code>,
							<code class="inline">IMPERIAL</code>,
							etc ...
						</li>
					</ol>
					<p>
						Write code to convert each character name to a <code class="inline">StarWarsCharacter</code> object.
					</p>
					<ul>
						<li>
							<sub>
								<strong>Hint:</strong> Try to create the conversion as extension function on <code class="inline">String</code>,
								accepting a <code class="inline">Fraction</code> as an argument.
							</sub>
						</li>
					</ul>
					<p>
						Finally convert both lists to a list of <code class="inline">StarWarsCharacter</code> objects.
					</p>
					<blockquote>
						Feel free to chose a different theme if you don't like StarWars.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Exercise #2</h3>
				<div class="content">
					<p>
						Create a function that will accept the two lists of <strong>StarWarsCharacter</strong> objects,
						and will pair each character from the first list with a character from the second list.
					</p>
					<ul>
						<li>To do so, use the <code class="inline">mapIndexed</code> function.</li>
						<li>The return type should be <code class="inline">List&lt;Pair&ltlStarWarsCharacter, StarWarsCharacter&gt;&gt;</code></li>
						<li>Make sure to handle the case where characters cannot be paired.</li>
					</ul>
					<p>
						Call the function and save it's return value to a variable. You should now have something like:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to StarWarsCharacter("Darth Vader", Fraction.SITH),
								StarWarsCharacter("Yoda", Fraction.JEDI) to StarWarsCharacter("Emperor Palpatine", Fraction.SITH),
							)
						</code>
					</pre>
					<p>
						Create a simulated <code>round</code> function to simulate a fight between the characters.
						You can just pick a random winner.
						Return match result as a <code class="inline">List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;</code>.
					</p>
					<p>Example:</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 0,
								StarWarsCharacter("Darth Vader", Fraction.SITH) to 1,
								// ...
							)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise #3</h3>
				<div class="content">
					<p>
						Call the <code>map</code> function on the list of pairs from the previous exercise,
						use the <code class="inline">round</code> and save the result to a variable.
					</p>
					<p>
						Update the code so that each character pair performs 3 matches. This will give you
						<br />
						<code class="inline">List&lt;List&lt;Pair&lt;Int, List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;&gt;&gt;&gt;</code>
						<br />
						where the data structure reflects
						<br />
						<code class="inline">listOf(roundNumber to listOf(character to score))</code>.
					</p>
					<p>
						The result should look like this:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val exampleResult: List&lt;List&lt;Pair&lt;Int, List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;&gt;&gt;&gt; = listOf(
								listOf(
									1 to listOf(
										StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 0,
										StarWarsCharacter("Darth Vader", Fraction.SITH) to 1,
									),
									2 to listOf(
										StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 1,
										StarWarsCharacter("Darth Vader", Fraction.SITH) to 0
									),
									// 3 to listOf(...)
								),
								listOf(
									1 to listOf(
										StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
										StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
									),
									2 to listOf(
										StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
										StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
									),
									// 3 to listOf(...)
								),
								// listOf(...)
							)
						</code>
					</pre>
					<p>
						Extract the code into a function. We might use it later. Again, it might be nice to create it
						as extension function.
					</p>
				</div>
			</section>
			<section>
				<h3>Exercise #4</h3>
				<div class="content">
					<p>
						Create another function which will perform a match called <code class="inline">matchWithFlatResults</code>.
						This function will perform the same thing as <code class="inline">match</code> except it will
						return a flat list of results.
						<br />
						<code class="inline">List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;</code>
						<br />
						where the data structure reflects
						<br />
						<code class="inline">listOf(character to score)</code>.
					</p>
					<p>
						The result should look like this:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val exampleResult: List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt; = listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 0,
								StarWarsCharacter("Darth Vader", Fraction.SITH) to 1,
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 1,
								StarWarsCharacter("Darth Vader", Fraction.SITH) to 0
								StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
								StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
								StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
								StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
								// ...
							)
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Filtering Functions</h2>
			</section>
			<section>
				<h3>Filtering</h3>
				<div class="summary">
					Kotlin SDK again provides us with a rich set of functions for filtering collections.
					Like map, filter returns a new collection with the elements that satisfy a predicate.
				</div>
				<div class="content">
					<p>
						Generally, the returned collection is the same type as the original collection.
					</p>
					<p>
						Some of the filter functions available in the Kotlin standard library include:
					</p>
					<ul>
						<li>
							<code class="inline">filter</code>
							- filters elements based on a predicate and returns a list of elements that satisfy the predicate.
						</li>
						<li>
							<code class="inline">filterNot</code>
							- filters elements based on a predicate and returns a list of elements that do not satisfy the predicate.
						</li>
						<li>
							<code class="inline">filterNotNull</code>
							- filters out null elements and returns a list of non-null elements.
						</li>
						<li>
							<code class="inline">filterIndex</code>
							- filters elements based on a predicate with index and returns a list of elements that satisfy the predicate.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<p>
						Using code from the previous exercise, create a list of characters for each fraction.
					</p>
					<p>
						Example:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val characters = listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI),
								StarWarsCharacter("Yoda", Fraction.JEDI),
								StarWarsCharacter("Obi-Wan Kenobi", Fraction.JEDI),
								StarWarsCharacter("Mace Windu", Fraction.JEDI),
								StarWarsCharacter("Qui-Gon Jinn", Fraction.JEDI),
								StarWarsCharacter("Darth Vader", Fraction.SITH),
								StarWarsCharacter("Emperor Palpatine", Fraction.SITH),
								StarWarsCharacter("Darth Maul", Fraction.SITH),
								StarWarsCharacter("Kylo Ren", Fraction.SITH),
								StarWarsCharacter("Count Dooku", Fraction.SITH),
								StarWarsCharacter("Leia Organa", Fraction.REBEL),
								StarWarsCharacter("Han Solo", Fraction.REBEL),
								StarWarsCharacter("Chewbacca", Fraction.REBEL),
								StarWarsCharacter("C3PO", Fraction.REBEL),
								StarWarsCharacter("R2D2", Fraction.REBEL),
								StarWarsCharacter("Stormtrooper", Fraction.IMPERIAL),
								StarWarsCharacter("Imperial Officer", Fraction.IMPERIAL),
								StarWarsCharacter("Imperial Guard", Fraction.IMPERIAL),
								StarWarsCharacter("Death Trooper", Fraction.IMPERIAL),
								StarWarsCharacter("TIE Fighter Pilot", Fraction.IMPERIAL)
							)
						</code>
					</pre>
					<p>
						Filter the collection to get only the characters:
					</p>
					<ol>
						<li>All characters belonging to <code class="inline">JEDI</code> or <code class="inline">REBEL</code> fraction</li>
						<li>All characters NOT belonging to <code class="inline">JEDI</code> or <code class="inline">REBEL</code> fraction</li>
					</ol>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Grouping and Sorting Functions</h2>
			</section>
			<section>
				<h3>Grouping</h3>
				<div class="summary">
					Given a collection, you can group elements based on a key.
				</div>
				<div class="content">
					<p>
						The result of grouping operations is a map where the key is the result of the selector function and the value is a list of elements.
					</p>
					<p>
						Some of the grouping functions available in the Kotlin SDK include:
					</p>
					<ul>
						<li>
							<code class="inline">groupBy</code>
							- groups elements by the result of the given selector function.
						</li>
						<li>
							<code class="inline">partition</code>
							- splits the collection into a pair of lists based on a predicate.
						</li>
						<li>
							<code class="inline">associate</code>
							- creates a map from the elements of the collection.
						</li>
						<li>
							<code class="inline">associateBy</code>
							- creates a map from the elements of the collection using the provided key selector function.
						</li>
						<li>
							<code class="inline">associateWith</code>
							- creates a map from the elements of the collection using the provided value selector function.
						</li>
					</ul>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									val priceList = listOf(
										"Mango" to 20,
										"Apple" to 25,
										"Banana" to 10,
										"Coconut" to 15,
										"Pineapple" to 30,
										"Orange" to 5,
										"Grapes" to 40
									)

									val priceCategory = priceList.groupBy { (_, price) ->
										when (price) {
											in 0..10 -> "Cheap"
											in 11..20 -> "Affordable"
											in 21..30 -> "Expensive"
											else -> "Very Expensive"
										}
									}
								</code>
							</pre>
						</div>
						<div class="column">
							<p>
								Result of this will be:
							</p>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									Affordable=[(Mango, 20), (Coconut, 15)]
									Expensive=[(Apple, 25), (Pineapple, 30)]
									Cheap=[(Banana, 10), (Orange, 5)]
									Very Expensive=[(Grapes, 40)]
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Sorting</h3>
				<div class="summary">
					Collections can be sorted in various ways using the Kotlin SDK.
				</div>
				<div class="content">
					<ul>
						<li>
							<code class="inline">sorted</code>
							- sorts elements in natural order.
						</li>
						<li>
							<code class="inline">sortedBy</code>
							- sorts elements by the result of the given selector function.
						</li>
						<li>
							<code class="inline">sortedWith</code>
							- sorts elements using the given comparator.
						</li>
						<li>
							<code class="inline">sortedDescending</code>
							- sorts elements in reverse natural order.
						</li>
						<li>
							<code class="inline">sortedByDescending</code>
							- sorts elements by the result of the given selector function in reverse order.
						</li>
						<li>
							<code class="inline">reversed</code>
							- reverses the order of elements in the collection.
						</li>
						<li>
							<code class="inline">shuffled</code>
							- shuffles the elements in the collection.
						</li>
					</ul>
					<p>
						Examples:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								val priceList = listOf(
									"Mango" to 20,
									"Apple" to 25,
									"Banana" to 10,
									"Coconut" to 15,
									"Pineapple" to 30,
									"Orange" to 5,
									"Grapes" to 40
								)

								priceList.sortedBy { (_, price) -> price }

								priceList.sortedByDescending { (_, price) -> price }

								priceList.sortedWith(
									compareBy(
										{ it.first },
										{ it.second }
									)
								)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<p>
						Given code from previous lessons, create light and dark side fractions collections and perform a matchWithFlatResults.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val lightSide = starWarsCharacters.filter { it.fraction in setOf(Fraction.JEDI, Fraction.REBEL) }
							val darkSide = starWarsCharacters.filterNot { it.fraction in setOf(Fraction.JEDI, Fraction.REBEL) }

							val results = createPairs(
								fraction1 = lightSide,
								fraction2 = darkSide
							).matchWithFlatResults()
						</code>
					</pre>
					<p>
						User <code class="inline">groupBy</code> and <code class="inline">sortedBy</code>
						functions to group and sort the results by:
					</p>
					<ul>
						<li>character</li>
						<li>fraction</li>
					</ul>
					<p>
						Use map function to calculate sum of scores by:
					</p>
					<ul>
						<li>character</li>
						<li>fraction</li>
					</ul>
					<p>Sort the scoreboard from highest to the lowest score.</p>
					<p>
						Of course, you may use other functions you know as well.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Other Transformation Functions</h2>
			</section>
			<section>
				<h3>Other Transformation Functions</h3>
				<!--				<div class="summary">-->
				<!--					TODO-->
				<!--				</div>-->
				<div class="content">
					<p>
						There are even more useful transformation functions available in the Kotlin SKD. Some worth mentioning are:
					</p>
					<ul>
						<li>
							<code class="inline">reduce</code>
							- combines elements of a collection into a single value.
						</li>
						<li>
							<code class="inline">zip</code>
							- combines two collections into a single collection of pairs.
						</li>
						<li>
							<code class="inline">zipWithNext</code>
							- combines each element with the next element in the collection.
						</li>
						<li>
							<code class="inline">unzip</code>
							- splits a collection of pairs into two collections.
						</li>
						<li>
							<code class="inline">flatten</code>
							- flattens a collection of collections into a single collection.
						</li>
						<li><code class="inline">fold</code>
							- combines elements of a collection into a single value starting with an initial value.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<ol>
						<li>
							Remember how we used <code class="inline">mapIndexed</code> to create a list of pairs of characters?
							Try using <code class="inline">zip</code> instead.
						</li>
						<li>
							Try <code class="inline">unzip</code> the list of pairs into two separate lists.
							And why not try <code class="inline">zipWithNext</code>? Just for fun.
						</li>
						<li>
							Try to use <code class="inline">groupBy</code>, <code class="inline">map</code> and <code class="inline">reduce</code>
							to create the scoreboard by character.
						</li>
						<li>
							Try use <code class="inline">fold</code> to create the scoreboard by fraction.
						</li>
					</ol>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Sequence</h2>
			</section>
			<section>
				<h3>Sequence</h3>
				<div class="summary">
					Kotlin standard library provides a <span class="highlight">Sequence</span> additional to collections.
				</div>
				<div class="content">
					<p>
						Unlike collections, sequences don't contain elements, they produce them while iterating.
						This is useful when you need to perform multi-step operations on a collection.
					</p>
					<p>
						<strong class="highlight">Operations on collections are executed eagerly</strong>, meaning they perform all operations on all elements immediately.
						<br />
						<strong class="highlight">Operations sequences are executed lazily</strong>, meaning they perform operations on elements only when needed.
					</p>
					<p>
						This can be beneficial for large collections or when you need to perform complex operations on elements.
						<br />
						On the other hand, sequences may be less efficient for small collections or simple operations.
					</p>
					<p>
						Sequences offer the similar functions as collections, such as <code class="inline">forEach</code>, <code class="inline">map</code>, <code class="inline">filter</code>, etc.
					</p>
					<p>
						The main difference is that when working with sequences, we distinguish between <span class="highlight">intermediate and terminal operations</span>,
						where intermediate operations return a new sequence and terminal operations return a result.
					</p>
					<p>
						What that means is that <span class="highlight">when you call a terminal operation, all intermediate operations are executed and the collection is so called "consumed"</span>.
					</p>
					<blockquote>
						<strong>!!!</strong>&nbsp;&nbsp;&nbsp;
						Keep this in mind because if you call a terminal operation prematurely, you may either end up with unexpected results,
						or at least with a performance hit.
						&nbsp;&nbsp;&nbsp;<strong>!!!</strong>
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Creating Sequences</h3>
				<div class="content">
					From elements:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = sequenceOf(1, 2, 3, 4, 5)
						</code>
					</pre>
					From an Iterable:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = listOf(1, 2, 3, 4, 5).asSequence()
						</code>
					</pre>
					From a function:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = generateSequence(1) { it + 1 }
						</code>
					</pre>
					From chunks:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = sequence {
								for (i in 1..5) {
									yield(i)
								}
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Practice</h2>
				<em>↓</em>
			</section>
			<section>
				<h3>Practice: part 1</h3>
				<div class="summary">
					Going back to lesson 5, extend the fantasy game model as follows.
				</div>
				<div class="content">
					<p>
						<strong>I will check your solutions tomorrow!</strong>
					</p>
					<ol>
						<li>
							Create new class <strong>Match</strong> with properties:
							<ul>
								<li><code class="inline">rounds: Int</code></li>
								<li><code class="inline">challenger: Character</code></li>
								<li><code class="inline">opponent: Character</code></li>
							</ul>
						</li>
						<li>
							And a function <code class="inline">fight</code> to the <strong>Match</strong> class
							that will simulate the match and return the winner as <code class="inline">Character?</code>.
							<br />
							You can use code from your previous solution,
							and use the <code class="inline">rounds</code> variable set number of rounds.
						</li>
						<li>
							Update your <strong>main</strong> function to create a <strong>Match</strong> object and execute the fight.
						</li>
					</ol>
				</div>
				<br />
				<br />
				<br />
				<em>Continue to part 2 ↓</em>
			</section>
			<section>
				<h3>Practice: part 2</h3>
				<div class="content">
					<ol>
						<li>
							Create a new interface <code class="inline">Recoverable</code> with with two functions:
							<ul>
								<li><code class="inline">beforeRounds</code></li>
								<li><code class="inline">afterRound</code></li>
							</ul>
						</li>
						<li>
							Extend <strong>Character</strong> with the <code class="inline">Recoverable</code> interface.
						</li>
						<li>
							Update <strong>Warrior</strong> and <strong>Sorcerer</strong> classes to implement the <code class="inline">Recoverable</code> interface.
							<ul>
								<li>
									<code class="inline">beforeRounds</code> should increase the <code class="inline">stamina</code> and <code class="inline">mana</code> by 1.
								</li>
								<li>
									<code class="inline">afterRound</code> - should do nothing for now.
								</li>
							</ul>
						</li>
						<li>
							Update <strong>Match</strong> <code class="inline">fight</code> function to call <code class="inline">beforeRounds</code> and <code class="inline">afterRound</code> functions.
						</li>
					</ol>
				</div>
				<br />
				<br />
				<br />
				<em>Continue to part 3 ↓</em>
			</section>
			<section>
				<h3>Practice: part 3</h3>
				<div class="content">
					<ol>
						<li>
							Create a new enum class <code class="inline">CharacterLevel</code> with 10 levels.
							The enum should have points property which will represent the level points which you can distribute to the character attributes.
							Chose the number of points you want to distribute.
						</li>
						<li>
							Update the <strong>Character</strong> class to have a new abstract property <code class="inline">level</code> of type <code class="inline">CharacterLevel</code>.
						</li>
						<li>
							Add <strong>level</strong> to the <strong>Warrior</strong> and <strong>Sorcerer</strong> classes.
						</li>
						<li>
							Add a constructor validation to each character class to check if the level points are distributed correctly
							(not exceeding maximum level points).
						</li>
					</ol>
				</div>
				<br />
				<br />
				<br />
				<em>Feel free to refactor your code with all the new knowledge.</em>
			</section>
		</section>


		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Packages, Imports and Modifiers</h2>
			</section>
			<section>
				<h3>Packages</h3>
				<div class="summary">
					Packages are used to organize code into namespaces, making it easier to manage and avoid naming conflicts.
					<!--					Packages are a way of organizing code. They are basically directories.-->
				</div>
				<div class="content">
					<ul>
						<li>The package declaration is usually the first line in a Kotlin file. It specifies the package to which the file belongs.</li>
						<li>Package names are typically written in all lowercase and follow the reverse domain name convention.</li>
						<li>To use classes and functions from other packages, you need to <code class="inline">import</code> them using the import keyword.</li>
						<li>If no package is specified, the file belongs to the default package.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package com.motycka.edu.model // <- package name

							import java.time.LocalDate // <- import of class LocalDate from java.time package

							class User(
								val name: String,
								val birthDate: LocalDate
							)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Modifiers</h3>
				<div class="summary">
					Modifiers in programming languages are keywords that you can use to change the properties or behavior of classes, methods, and variables.
				</div>
				<div class="content">
					<p>
						They can be broadly categorized into two types:
					</p>
					<br />
					<h4>Access Modifiers</h4>
					<p>
						These define the visibility or accessibility of functions, classes, methods, and variables.
					</p>
					<br />
					<h4>Non-Access Modifiers</h4>
					<p>
						These define other characteristics such as behavior, state, or implementation details.
					</p>
				</div>
			</section>
			<section>
				<h3>Access Modifiers</h3>
				<div class="summary">
					Access, modifiers define the visibility or accessibility of functions, classes, methods, and variables.
				</div>
				<div class="content">
					<table>
						<thead>
						<tr>
							<td><strong>modifier</strong></td>
							<td><strong>on class</strong></td>
							<td><strong>on method</strong></td>
							<td><strong>on field</strong></td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td><strong><code class="inline">public</code></strong></td>
							<td>accessible from anywhere</td>
							<td>accessible from anywhere</td>
							<td>accessible from anywhere</td>
						</tr>
						<tr>
							<td><strong><code class="inline">private</code></strong></td>
							<td>only accessible within the same package</td>
							<td>only accessible within same class</td>
							<td>only accessible within same class</td>
						</tr>
						<tr>
							<td><strong><code class="inline">protected</code></strong></td>
							<td>accessible within the same package</td>
							<td>only accessible within same class or it's subclass</td>
							<td>only accessible within same class or it's subclass</td>
						</tr>
						<tr>
							<td><strong><code class="inline">internal</code></strong></td>
							<td>accessible within the same module</td>
							<td>accessible within the same module</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><span style="font-style: italic">default</span></td>
							<td>same as public</td>
							<td>same as public</td>
							<td>same as public</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Non-Access Modifiers</h3>
				<div class="summary">
					Non-access modifiers define other characteristics such as behavior, state, or implementation details.
				</div>
				<div class="content" style="font-size: 70%">
					<table>
						<thead>
						<tr>
							<td><strong>modifier</strong></td>
							<td><strong>on class</strong></td>
							<td><strong>on method / block</strong></td>
							<td><strong>on field</strong></td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td><code class="inline">abstract</code></td>
							<td>Class marked as abstract cannot be directly instantiated.</td>
							<td>Method marked as abstract does not provide implementation, but expects a <em>subclass</em> to implement it.</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><code class="inline">final</code></td>
							<td>prevents inheritance</td>
							<td>prevents method overloading</td>
							<td>Makes variable a constant = value cannot be changed after initialization.</td>
						</tr>
						<tr>
							<td><code class="inline">open</code></td>
							<td>Allows class to be inherited</td>
							<td>Allows method to be overridden</td>
							<td>Allows property to be changed</td>
						</tr>
						<tr>
							<td><code class="inline">override</code></td>
							<td>N/A</td>
							<td>Indicates that a method is overriding a method in a superclass.</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><code class="inline">lateinit</code></td>
							<td>N/A</td>
							<td>Indicates that a property will be initialized later.</td>
							<td>N/A</td>
						</tr>
						<tr>
							<td><code class="inline">const</code></td>
							<td>N/A</td>
							<td>N/A</td>
							<td>Indicates that a property is a compile-time constant.</td>
						</tr>
						<tr>
							<td><code class="inline">companion</code></td>
							<td>N/A</td>
							<td>N/A</td>
							<td>Defines a companion object, which is an object that is tied to a class and can access its private members.</td>
						</tr>
						<!--						<tr>-->
						<!--							<td><strong><code>static</code></strong></td>-->
						<!--							<td>N/A</td>-->
						<!--							<td>accessible without need to create class instance</td>-->
						<!--							<td>Make variable global, also called <em>class variable</em>, as opposed to <em>instance variable</em>.</td>-->
						<!--						</tr>-->
						<!--						<tr>-->
						<!--							<td><strong><code>synchronized</code></strong></td>-->
						<!--							<td>N/A</td>-->
						<!--							<td>Used to control access to an object by multiple threads. It is primarily used to prevent thread interference.</td>-->
						<!--							<td>N/A</td>-->
						<!--						</tr>-->
						<!--						<tr>-->
						<!--							<td><strong><code>volatile</code></strong></td>-->
						<!--							<td>N/A</td>-->
						<!--							<td>N/A</td>-->
						<!--							<td>Used in multi-threaded environment, ensures that changes made in one thread are immediately reflect in another thread.</td>-->
						<!--						</tr>-->
						<!--						<tr>-->
						<!--							<td><strong><code>native</code></strong></td>-->
						<!--							<td>N/A</td>-->
						<!--							<td>Used to declare a method that is implemented in native code using JNI (Java Native Interface).</td>-->
						<!--							<td>N/A</td>-->
						<!--						</tr>-->
						<!--						<tr>-->
						<!--							<td><strong><code>transient</code></strong></td>-->
						<!--							<td>N/A</td>-->
						<!--							<td>N/A</td>-->
						<!--							<td>Used in object serialization, it indicates that a field should not be serialized.</td>-->
						<!--						</tr>-->
						</tbody>
					</table>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Practice</h2>
				<em>Let's write some code!</em>
			</section>
		</section>
	</div>
</div>

<script src="./dist/reveal.js"></script>
<script src="./plugin/notes/notes.js"></script>
<script src="./plugin/markdown/markdown.js"></script>
<script src="./plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	})
	Reveal.configure({ showNotes: false })
</script>
</body>
</html>
