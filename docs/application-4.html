<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/vs.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 3 | Lesson 14</i>
			<h1>Spring Boot Application</h1>
			<em>Common Architecture Patterns</em><br />
			<em>Service Design Patterns</em><br />
			<em>Reactive streams</em><br />
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Application Architecture</h2>
			</section>
			<section>
				<h3>Common Architecture Patterns</h3>
				<div class="summary">
					There are several common architecture patterns that are used in the development of software applications.

				</div>
				<div class="content">
					<p>
						These are high-level application architecture patterns used to define the structure of the application and the way in which the different components of the application interact with each other.
					</p>
					<p>
						<strong>Some</strong> of the most common architecture patterns include:
					</p>
					<ul>
						<li>Monolithic Architecture</li>
						<li>Microservice Architecture</li>
						<li>Serverless Architecture</li>
						<li>Event-Driven Architecture</li>
						<li>API Gateway Architecture</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Monolithic Architecture</h3>
				<div class="summary">
					Monolithic architecture is a software architecture pattern where all the components of the application run as a single unit.
				</div>
				<div class="content">
					<p>
						Monolithic architecture tends to be tightly coupled, which can make it difficult to scale and maintain the application over time.
					</p>
					<ul>
						<li>
							<strong class="highlight">When to use</strong>
							<ul>
								<li>Small projects or MVPs.</li>
								<li>Early-stage startups.</li>
								<li>Teams with limited resources.</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Pros</strong>
							<ul>
								<li>Easier debugging with one codebase.</li>
								<li>
									Simpler to develop and deploy. **
									<sub>In terms of needing simper infrastructure.</sub>
								</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Cons</strong>
							<ul>
								<li>Difficult to scale certain parts independently.</li>
								<li>Harder to manage as the codebase grows.</li>
								<li>Limited error resilience.</li>
								<li>Difficult to develop and deploy. **
									<sub>Monoliths can have many dependencies to for developers, that may mean a lot of setup.</sub>
								</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Microservice Architecture</h3>
				<div class="summary">
					An architecture that decomposes the system into smaller, (relatively) independent services.
				</div>
				<div class="content">
					<ul>
						<li>
							<strong class="highlight">When to use</strong>
							<ul>
								<li>Large, complex systems.</li>
								<li>Teams that are distributed or domain-focused.</li>
								<li>Scalability is a top priority.</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Pros</strong>
							<ul>
								<li>Independent scaling and deployment.</li>
								<li>Fault isolation (failures in one service don't affect others).</li>
								<li>Easier to adopt different tech stacks per service.</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Cons</strong>
							<ul>
								<li>Complex to manage (e.g., inter-service communication).</li>
								<li>Potential for high latency between services.</li>
								<li>Requires solid observability (monitoring, logging).</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Pitfalls</strong>
							<ul>
								<li><strong>Be aware of distributed monoliths!</strong></li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Serverless Architecture</h3>
				<div class="summary">
					Uses cloud-managed services where you write and deploy functions instead of managing infrastructure.
				</div>
				<div class="content">
					<ul>
					<li>
						<strong class="highlight">When to use</strong>
						<ul>
							<li>Event-driven systems (e.g., IoT data, notifications).</li>
							<li>Applications with unpredictable or spiky traffic.</li>
						</ul>
					</li>
					<li>
						<strong class="highlight">Pros</strong>
						<ul>
							<li>Automatic scaling.</li>
							<li>Reduced operational complexity.</li>
							<li>Pay-per-use model.</li>
						</ul>
					</li>
					<li>
						<strong class="highlight">Cons</strong>
						<ul>
							<li>Cold-start latency.</li>
							<li>Vendor lock-in risks.</li>
							<li>Debugging and monitoring can be more complex.</li>
						</ul>
					</li>
				</ul>
				</div>
			</section>
			<section>
				<h3>Event-Driven Architecture</h3>
				<div class="summary">
					Systems that react to and propagate events across services (e.g., Kafka, RabbitMQ).
				</div>
				<div class="content">
					<ul>
						<li>
							<strong class="highlight">When to use</strong>
							<ul>
								<li>Systems with high-frequency event generation.</li>
								<li>IoT and real-time analytics.</li>
								<li>Applications with loosely coupled services.</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Pros</strong>
							<ul>
								<li>Real-time processing and responsiveness.</li>
								<li>Highly scalable and decoupled.</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Cons</strong>
							<ul>
								<li>Requires careful event design to avoid excessive coupling.</li>
								<li>Complex debugging and replaying of events.</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>API Gateway Architecture</h3>
				<div class="summary">
					Centralizes all API traffic, often for microservices and serverless backends.
				</div>
				<div class="content">
					<ul>
						<li>
							<strong class="highlight">When to use</strong>
							<ul>
								<li>Systems with multiple backend services.</li>
								<li>Teams needing centralized authentication, logging, or throttling.</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Pros</strong>
							<ul>
								<li>Centralized management for APIs.</li>
								<li>Reduced cross-cutting concerns (e.g., rate limiting, CORS).</li>
							</ul>
						</li>
						<li>
							<strong class="highlight">Cons</strong>
							<ul>
								<li>Can become a single point of failure.</li>
								<li>Latency and complexity if overloaded.</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>How to decide?</h3>
				<div class="content content-center content-100">
					<p class="fragment fade-in">You will get it wrong!</p>
					<p class="fragment fade-in">And you will re-do it.</p>
					<p class="fragment fade-in">And you will still get it wrong again.</p>
					<p class="fragment fade-in">And then you will re-do it again.</p>
					<p class="fragment fade-in">And it will never be perfect.</p>
					<p class="fragment fade-in">And that's OK.</p>
					<br />
					<p class="fragment fade-in" data-transition="fade-in">Embrace failure, learn from it, and go on.</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Service Design Patterns</h2>
			</section>
			<section>
				<h3>Service Architecture</h3>
				<div class="summary">
					When designing your application, it is important to consider the architecture of your services.
				</div>
				<div class="content" style="font-size: 70%">
					<h4>Separation of concerns</h4>
					<p>
						It is a good practice to split your code by domain, where each service is responsible for a specific domain or business logic.
						If you domains need to interact with each other, be careful to not create cross dependencies that would break the domain separation.
					</p>
					<p>
						Well designed dependencies might look like this:
					</p>
					<ul>
						<li>
							<strong class="highlight">Controller -> Service</strong> within the same domain
						</li>
						<li>
							<strong class="highlight">Service -> Repository</strong> within the same domain
						</li>
						<li>
							<strong class="highlight">Service -> Service</strong> within the same domain
						</li>
						<li>
							<strong class="highlight">Service -> Service</strong> across a domain - you may want a dedicated cross domain service
						</li>
						<li>
							<strong class="highlight">Repository -> Repository</strong> within the same domain
						</li>
					</ul>
					<p>
						A rule of thumb here is, when you can take your domain and spilt it into separate services with minimal effort, they you probably have a good design.
					</p>
					<p>
						<strong>
							A good approach to this is to use interfaces where services are defined and implemented in separate modules.
						</strong>
					</p>
					<h4>Internal and external data models</h4>
					<p>
						It is good idea to have separate classes representing the internal and external data models.
						For example, you might have a <code class="inline">User</code> class that is used internally by your service and a <code class="inline">NewUserRequest</code> and <code class="inline">UserResponse</code> class that is used to represent the user in the API.
						The internal object may have some properties logic and content that you don't want to expose externally.
						Also, you do not want changes made to the internal object to affect the external object contract.
					</p>
				</div>
			</section>
			<section>
				<h3>Event Bases Architecture</h3>
				<div class="summary">
					Event based architecture is a software architecture pattern where the different components
					of the application communicate with each other by sending and receiving events.
				</div>
				<div class="content">
					<p>
						Event based architecture is a popular choice for building distributed systems because
						it allows for loose coupling between the different components of the system.
					</p>
					<blockquote>
						It is not only limited to service-to-service communication, but can also be used to communicate within a single service.
					</blockquote>
					<p>
						It can often be described as a <strong class="highlight">fire and forget</strong> model, where the sender of the event does not need to wait for a response from the receiver.
					</p>
					<p>
						There are multiple ways to implement this architecture:
					</p>
					<ul>
						<li>
							Using <strong class="highlight">Publish/Subscribe</strong> model<br />
							<em>Where events are published to a topic and multiple subscribers can receive the event.</em>
						</li>
						<li>
							Using <strong class="highlight">Message Queues</strong><br />
							<em>Where events are sent to a queue and processed by a single consumer.</em>
						</li>
						<li>
							Using <strong class="highlight">Event Sourcing</strong><br />
							<em>Where the state of the system is determined by a sequence of events.</em>
						</li>
					</ul>
					<p>
						Message brokers like <strong class="highlight">Kafka</strong>, <strong class="highlight">RabbitMQ</strong>, and <strong class="highlight">Amazon SQS</strong> are commonly used to implement event based architectures.
					</p>
				</div>
			</section>
			<section>
				<h3>Event Bases Architecture</h3>
				<div class="content">
					<p>
						<strong class="highlight">When to use</strong>
					</p>
					<ul>
						<li>Applications that need to be highly scalable.</li>
						<li>Applications that need to be highly available.</li>
						<li>Applications that need to be fault-tolerant.</li>
					</ul>

					<p>
						<strong class="highlight">Pros</strong>
					</p>
					<ul>
						<li>Loose coupling between components.</li>
						<li>Highly scalable and available.</li>
						<li>Fault-tolerant.</li>
					</ul>
					<p>
						<strong class="highlight">Cons</strong>
					</p>
					<ul>
						<li>Complexity of managing events.</li>
						<li>Potential for event loss.</li>
						<li>Potential for event duplication.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Spring Application Events</h3>
				<div class="content">
					<p>
						Spring Framework provides a mechanism for implementing event-based architectures using the <code class="inline">ApplicationEvent</code> class and the <code class="inline">ApplicationEventPublisher</code> interface.
					</p>
					<p>
						You can create custom events by extending the <code class="inline">ApplicationEvent</code> class and publish them using the <code class="inline">ApplicationEventPublisher</code> interface.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Component
							class MyEventPublisher(
								private val applicationEventPublisher: ApplicationEventPublisher
							) {

								fun publishEvent() {
									applicationEventPublisher.publishEvent(MyCustomEvent(this, "Hello, World!"))
								}

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class MyCustomEvent(source: Any, val message: String) : ApplicationEvent(source)
						</code>
					</pre>
					<p>
						You can listen for custom events by implementing the <code class="inline">ApplicationListener</code> interface and annotating the listener with <code>@Component</code>.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Component
							class MyEventListener : ApplicationListener&lt;MyCustomEvent&gt; {

								override fun onApplicationEvent(event: MyCustomEvent) {
									println("Received event: ${event.message}")
								}

							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Reactive Streams</h2>
				<em>WebFlux</em>
			</section>
			<section>
				<h3>Spring WebFlux</h3>
				<div class="summary">
					Spring WebFlux and Spring MVC are both part of the Spring Framework and are used to build web applications,
					but they have different architectures and are suited for different types of workloads.
				</div>
				<div class="content" style="font-size: 70%">
					<div class="row">
						<div class="column">
							<h4>Spring MVC</h4>
						</div>
						<div class="column">
							<h4>Spring WebFlux</h4>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<p><strong class="highlight">Programming Model</strong></p>
						</div>
						<div class="column"></div>
					</div>
					<div class="row">
						<div class="column">
							<ul>
								<li>
									Follows the traditional blocking (synchronous) model where each request is processed by a dedicated thread.
								</li>
								<li>
									Uses the Servlet API, threads wait for I/O (e.g., database calls, external API responses).
								</li>
							</ul>
						</div>
						<div class="column">
							<ul>
								<li>
									Follows the non-blocking (reactive) programming model to process requests asynchronously,
								</li>
								<li>Users event-driven, non-blocking I/O to process requests without tying up threads.</li>
								<li>Based on Reactor and Netty.</li>
							</ul>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<p><strong class="highlight">Return Types</strong></p>
						</div>
						<div class="column"></div>
					</div>

					<div class="row">
						<div class="column">
							<ul>
								<li>
									Returns a  <code class="inline">ModelAndView</code>, or data types like <code class="inline">String</code>, <code class="inline">Long</code>, ... or <code class="inline">ResponseEntity</code>.
								</li>
								<li>
									Suitable for thread-per-request handling, but it can lead to thread exhaustion under high loads.
								</li>
							</ul>
						</div>
						<div class="column">
							<ul>
								<li>
									Often returns <code class="inline">Mono&lt;T&gt;</code> (for zero or one item) or <code class="inline">Flux&lt;T&gt;</code> (for multiple items) to represent asynchronous, reactive streams.
								</li>
								<li>
									Allows handling more concurrent requests with fewer threads by avoiding thread blocking.
								</li>
							</ul>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<p><strong class="highlight">Application Scenarios</strong></p>
						</div>
						<div class="column"></div>
					</div>
					<div class="row">
						<div class="column">
							<ul>
								<li>
									Traditional web applications (e.g., form-based apps, content-heavy sites).
								</li>
								<li>
									Easy to use for developers familiar with blocking I/O and imperative programming.
								</li>
							</ul>
						</div>
						<div class="column">
							<ul>
								<li>
									Ideal for microservices, event-driven systems, or streaming data scenarios (e.g., WebSockets, real-time applications).
								</li>
								<li>
									Great for APIs or services that require high throughput and low latency.
								</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Spring WebFlux</h3>
				<div class="summary">
					Using Reactor Flux and Mono types
				</div>
				<div class="content">
					<p>
						Controllers implemented using Spring <strong class="highlight">WebFlux</strong> can return
						<code>Flux&lt;T&gt;</code> and <code>Mono&lt;T&gt;</code>
						types to represent asynchronous, reactive streams.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@RestController
							@RequestMapping("/api/v1/hello")
							class HelloControllerV1(
								private val helloService: HelloService
							) {


								@GetMapping
								fun getHello(): Flux&lt;Hello&gt; = Flux.fromIterable(helloService.getHello())

								@GetMapping("/{locale}")
								fun getHello(
									@PathVariable(value = "locale") locale: String,
									@RequestParam(value = "name") name: String
								): Mono&lt;String&gt; = Mono.just(helloService.sayHello(name, locale))

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Service
							class HelloService(
								private val helloRepository: HelloRepository
							) {

								fun getHello(): List&lt;Hello&gt; = helloRepository.getHello()

								fun sayHello(name: String, locale: String): String = helloRepository.sayHello(name, locale)

							}
						</code>
					</pre>
				</div>
			</section>

			<section>
				<h3>Spring WebFlux with Kotlin Coroutines</h3>
				<div class="summary">
					Using Kotlin coroutines with Flow types
				</div>
				<div class="content">
					<p>
						There is an extension for Spring WebFlux that allows you to use Kotlin coroutines to write asynchronous, non-blocking code.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@RestController
								@RequestMapping("/api/v2/hello")
								class HelloControllerV2(
									private val helloService: HelloService
								) {

									@GetMapping
									suspend fun getHello(): Flow&lt;List&lt;Hello&gt;&gt; = helloService.getHelloAsync()

									@GetMapping("/{locale}")
									suspend fun getHello(
										@PathVariable(value = "locale") locale: String,
										@RequestParam(value = "name") name: String
									): Flow&lt;String&gt; = helloService.sayHelloAsync(name, locale)

								}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Service
							class HelloService(
								private val helloRepository: HelloRepository
							) {

								suspend fun getHelloAsync(): Flow&lt;List&lt;Hello&gt;&gt; = flow {
									emit(helloRepository.getHello())
								}

								suspend fun sayHelloAsync(name: String, locale: String): Flow&lt;String&gt; = flow {
									emit(helloRepository.sayHello(name, locale))
								}

							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section>
				<section data-background-gradient="var(--kotlin-gradient)">
					<h2>Project Work</h2>
					<em>â†“</em>
				</section>
				<section>
					<div style="font-size: 200%">
						<em>Are we done here?</em><br />
						<em>I hope not!</em>
					</div>
				</section>
			</section>
		</section>
	</div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
