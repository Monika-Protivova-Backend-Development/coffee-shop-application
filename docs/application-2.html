<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/vs.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 3 | Lesson 12</i>
			<h1>Spring Boot Application</h1>
			<em>Controller Layer (REST)</em><br />
			<em>Service Layer</em><br />
			<em>Testing</em><br />
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Fantasy.Space</h2>
				<em>Project Introduction</em>
			</section>
			<section>
				<h3>Fantasy.Space: Project</h3>
				<div class="content content-center content-100">
					<br />
					<p>
						<a href="https://github.com/motycka/fantasy-space-game">Use this GitHub project.</a>
					</p>
					<p>
						The requirements are in the README.
					</p>
					<p>
						Tet's get into it!
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Fantasy.Space</h2>
				<em>Character Controller</em>
			</section>
			<section>
				<h3>Fantasy.Space: Character Controller</h3>
				<div class="summary">
					The REST controller layer is responsible for handling the HTTP requests,
					passing them to the service layer, retrieving the results from the service layer,
					and returning HTTP responses.
				</div>
				<div class="content">
					<p>
						The REST Controller ...
					</p>
					<ul>
						<li>
							Defines methods and paths to resources
							<ul>
								<li>Path parameters</li>
								<li>Query parameters</li>
							</ul>
						</li>
						<li>
							Receives request from client and passes it to services
							<ul>
								<li>Handles deserialize/serialization of request/response body</li>
								<li>May do some error handling</li>
							</ul>
						</li>
						<li>
							Receives results from services and returns it to client
							<ul>
								<li>Returns HTTP status and response body</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Fantasy.Space: Character Controller</h3>
				<div class="content">
					<p>
						As said, the <code class="inline">@RestController</code> is used to define a class as a REST controller and
						<code class="inline">@RequestMapping</code> is used to define the root path to the resource.
					</p>
					<p>
						Any dependencies are injected into the controller using, constructor injection, setter injection, or field injection.
					</p>
					<p>
						Here is an example with constructor injection, which is the recommended way.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package com.motycka.edu.game.character

							import com.motycka.edu.game.account.AccountService
							import org.springframework.web.bind.annotation.RequestMapping
							import org.springframework.web.bind.annotation.RestController

							@RestController
							@RequestMapping("/api/characters")
							class CharacterController(
								private val characterService: CharacterService,
								private val accountService: AccountService
							) {

								// controller methods

							}

						</code>
					</pre>
					<p>
						Additional annotations are available, see Spring Boot documentation if you want to learn more.
					</p>
				</div>
			</section>
			<section>
				<h3>Fantasy.Space: Character Controller</h3>
				<div class="content">
					<p>
						Each method within the controller class is annotated with either
						<code class="inline">@GetMapping</code>, <code class="inline">@PostMapping</code>, <code class="inline">@PutMapping</code>,
						<code class="inline">@DeleteMapping</code>, or <code class="inline">@PatchMapping</code>, ith optional sub-path to the resource.
						This defines the HTTP method that the class method handles, and the path to the resource.
					</p>
					<p>
						This is example implementation of <strong class="highlight">GET</strong> method on resource <code class="inline">/api/characters</code>
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@GetMapping
							fun getCharacters(): List&lt;CharacterResponse&gt; {
								val accountId = accountService.getCurrentAccountId()
								return characterService.getCharacters(
									filter = CharactersFilter.DEFAULT
								).toCharacterResponses(accountId)
							}
						</code>
					</pre>
					<p>
						This is example implementation of <strong class="highlight">POST</strong> method on resource <code class="inline">/api/characters</code>
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@PostMapping
							fun postCharacter(
								@RequestBody character: CharacterCreateRequest
							): CharacterResponse {
								val accountId = accountService.getCurrentAccountId()
								return characterService.createCharacter(
									character = character.toCharacter(
										accountId = accountId
									)
								).toCharacterResponse(accountId)
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Fantasy.Space: Character Controller</h3>
				<div class="content">
					<p>
						Methods may declare path parameters or query parameters, and may return the response body and the HTTP status.
						Path parameters are defined using <code class="inline">@PathVariable</code> annotation,
						and query parameters are defined using <code class="inline">@RequestParam</code> annotation.
					</p>
					<p>
						Here is an example implementation of <strong class="highlight">GET</strong> method on resource <code class="inline">/api/characters/{characterId}</code>
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@GetMapping("/{id}")
							fun getCharacter(
								@PathVariable("id") characterId: CharacterId
							): CharacterResponse {

								// implementation

							}
						</code>
					</pre>
					<p>
						And hypothetical implementation of <strong class="highlight">GET</strong> method on resource <code class="inline">/api/character</code>
						with query parameter <code class="inline">class</code>
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@GetMapping
							fun getCharacter(
								@RequestParam("class", required = false) characterClass: String?,
							): List&lt;LeaderboardResponse&gt; {

								// implementation

							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Fantasy.Space: Character Controller (Final)</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package com.motycka.edu.game.character

							import com.motycka.edu.game.character.rest.*
							import com.motycka.edu.game.account.AccountService
							import org.springframework.web.bind.annotation.*

							@RestController
							@RequestMapping("/api/characters")
							class CharacterController(
								private val characterService: CharacterService,
								private val accountService: AccountService
							) {

								@PostMapping
								fun postCharacter(
									@RequestBody character: CharacterCreateRequest
								): CharacterResponse {
									val accountId = accountService.getCurrentAccountId()
									return characterService.createCharacter(
										character = character.toCharacter(
											accountId = accountId
										)
									).toCharacterResponse(accountId)
								}

								@GetMapping
								fun getCharacters(): List&lt;CharacterResponse&gt; {
									val accountId = accountService.getCurrentAccountId()
									return characterService.getCharacters(
										filter = CharactersFilter.DEFAULT
									).toCharacterResponses(accountId)
								}

							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Fantasy.Space</h2>
				<em>Character Service</em>
			</section>
			<section>
				<h3>Fantasy.Space: Character Service</h3>
				<div class="summary">
					The service layer in an MVC application is the layer that contains the <strong class="highlight">business logic</strong>.
				</div>
				<div class="content">
					<p>
						This layer is responsible for understanding the requests from the controller layer,
						making appropriate calls to the repository layer or other services, processing the data,
						and then and returning the result back to the controller layer (if applicable).
					</p>
					<p>
						Services will often use the repository layer to retrieve and store data and call other services to fulfill the requests.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package com.motycka.edu.game.character

							import com.motycka.edu.game.character.model.Character
							import com.motycka.edu.game.character.rest.CharactersFilter
							import com.motycka.edu.game.account.AccountService
							import org.springframework.stereotype.Service

							@Service
							class CharacterService(
								private val characterRepository: CharacterRepository,
								private val accountService: AccountService,
							) {

								fun createCharacter(character: Character): Character {
									return characterRepository.insertCharacters(
										accountId = accountService.getCurrentAccountId(),
										character = character
									) ?: error("Character could not be created.")
								}

								fun getCharacters(filter: CharactersFilter): List&lt;Character&gt; {
									val accountId = accountService.getCurrentAccountId()
									return characterRepository.selectWithFilter(accountId, filter)
								}

							}
						</code>
					</pre>
					<blockquote>
						<strong class="highlight">Business logic</strong> = the code that implements the business rules and requirements.
						In other words, the code that fulfills the customers needs and requirements should be placed in the service layer.
					</blockquote>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Testing</h2>
			</section>
			<section>
				<h3>Testing</h3>
				<div class="summary">
					Spring Boot also provides support for testing the application on each of the layers (controller, service, and repository).
				</div>
				<div class="content">
					<p>
						Testing each layer separately helps to make sure good separation of concerns and to make sure that each layer works as expected.
					</p>
					<p>
						It is also good, however, to test the application as a whole, to make sure that all the layers work together as expected.
					</p>
				</div>
			</section>
			<section>
				<h3>Mocking and spying</h3>
				<div class="summary">
					Mocking and spying are techniques used in testing to simulate the behavior of the objects that the class under test depends on.
				</div>
				<div class="content">
					<p>
						In other words, we can control the internal behavior of the dependencies form the tests.
					</p>
					<p>
						The "poor man's" version of mocking can be when we crate an alternative implementation of the class that is a dependency of the class under test.
					</p>
					<p>
						In reality, we use mocking frameworks, such as Mockito or MockK, to create mock objects and spy objects.
					</p>
				</div>
			</section>
			<section>
				<h3>Testing Controllers</h3>
				<div class="content">
					<div class="row">
						<p>
							Testing controllers is relatively simple, because they are just classes that handle the HTTP
							requests and return the HTTP responses. However, we need some tools to simulate the HTTP
							requests and responses.
						</p>
						<div class="column" style="width: 70%">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin" style="font-size: 80%">
									package com.motycka.edu.game.character

									import com.motycka.edu.game.account.AccountService
									import com.motycka.edu.game.character.model.CharacterLevel
									import com.motycka.edu.game.character.model.Warrior
									import com.motycka.edu.game.config.TestSecurityConfiguration
									import io.mockk.every
									import io.mockk.mockk
									import io.mockk.verify
									import org.junit.jupiter.api.BeforeEach
									import org.junit.jupiter.api.Test
									import org.springframework.beans.factory.annotation.Autowired
									import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
									import org.springframework.boot.test.mock.mockito.MockBean
									import org.springframework.context.annotation.Import
									import org.springframework.test.web.servlet.MockMvc
									import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
									import org.springframework.test.web.servlet.result.MockMvcResultMatchers.content
									import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
									import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf
									import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.httpBasic

									@WebMvcTest(CharacterController::class)
									@Import(TestSecurityConfiguration::class)
									class CharacterControllerTest {

										@Autowired
										private lateinit var mockMvc: MockMvc

										@MockBean
										private lateinit var characterService: CharacterService

										@MockBean
										private lateinit var accountService: AccountService

										private val accountId = 1L

										@BeforeEach
										fun setUp() {
											characterService = mockk()
											accountService = mockk()
										}

										@Test
										fun `postCharacter should return created character`() {
											val character = Warrior(
												id = 1,
												accountId = accountId,
												name = "Kotlin Warrior",
												health = 140,
												attackPower = 20,
												experience = 0,
												stamina = 20,
												defensePower = 20,
												level = CharacterLevel.LEVEL_1
											)

											every { accountService.getCurrentAccountId() } returns accountId
											every { characterService.createCharacter(any()) } returns character

											mockMvc.perform(post("/api/characters")
												.contentType("application/json")
												.content("""
												{
												  "name": "${character.name}",
												  "health": ${character.health},
												  "attackPower": ${character.attackPower},
												  "stamina": ${character.stamina},
												  "defensePower": ${character.defensePower},
												  "characterClass": "WARRIOR"
												}
												""".trimIndent())
												.with(csrf())
												.with(httpBasic("username", "password")))
												.andExpect(status().isOk)
												.andExpect(content().json(
													"""
													{
													  "id": ${character.characterId},
													  "name": "${character.name}",
													  "health": ${character.health},
													  "attackPower": ${character.attackPower},
													  "stamina": ${character.stamina},
													  "defensePower": ${character.defensePower},
													  "characterClass": "WARRIOR",
													  "level": "LEVEL_1",
													  "experience": 0,
													  "shouldLevelUp": false,
													  "isOwner": true,
													  "mana": null,
													  "healingPower": null
													}
												""".trimIndent()
												))

											verify { characterService.createCharacter(character = character) }
										}
									}

								</code>
							</pre>
						</div>
						<div class="column" style="font-size: 70%; width: 30%">
							<ul>
								<li>
									Spring Boot provides the <code class="inline">MockMvc</code> class to simulate the HTTP requests and responses.
								</li>
								<li>
									<code class="inline">@WebMvcTest</code> annotation with the controller class to be tested will establish a Spring context.
								</li>
								<li>
									<code class="inline">@Autowired</code> annotation is used to inject the <code class="inline">MockMvc</code> bean into the test class.
								</li>
								<li>
									Ideally, we want to test just the controller, but not the service and repository layers,
									so we can use the <code class="inline">@MockBean</code> annotation to mock the service and repository beans.
								</li>
								<li>
									We can mock the service layer using any mocking library, such as Mockito.
									In this case we use <code class="inline">mockk.every</code> to mock the service method and <code class="inline">mockk.verify</code> to verify the calls.
								</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Testing Services</h3>
				<div class="content">
					<p>
						Testing the service layer is perhaps the easiest, because we only need to mock the repository layer.
						There are multiple approaches you can take.
					</p>
					<div class="row" style="font-size: 80%">
						<div class="column">
							Either you can test the service layer using Spring Boot's dependency injection,
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									package com.motycka.edu.game.character

									import com.motycka.edu.game.account.AccountService
									import com.motycka.edu.game.character.model.CharacterLevel
									import com.motycka.edu.game.character.model.Warrior
									import com.motycka.edu.game.character.rest.CharactersFilter
									import org.junit.jupiter.api.Assertions.assertEquals
									import org.junit.jupiter.api.BeforeEach
									import org.junit.jupiter.api.Test
									import org.springframework.beans.factory.annotation.Autowired
									import org.springframework.boot.test.context.SpringBootTest
									import org.springframework.transaction.annotation.Transactional

									@SpringBootTest
									@Transactional
									class CharacterServiceIT {

										@Autowired
										private lateinit var characterRepository: CharacterRepository

										@Autowired
										private lateinit var accountService: AccountService

										@Autowired
										private lateinit var characterService: CharacterService

										private val accountId = 1L

										@Test
										fun `createCharacter should return created character`() {
											val character = Warrior(
												id = 1,
												accountId = accountId,
												name = "Warrior",
												health = 140,
												attackPower = 20,
												experience = 0,
												stamina = 20,
												defensePower = 20,
												level = CharacterLevel.LEVEL_1
											)

											val result = characterService.createCharacter(character)

											assertEquals(character, result)
											val savedCharacter = characterRepository.selectWithFilter(
												accountId = accountId,
												filter = CharactersFilter.DEFAULT.copy(ids = setOf(character.characterId))
											)
											assertEquals(character, savedCharacter)
										}
									}
								</code>
							</pre>
							The advantage of this is you are testing the service can be injected correctly.
							The disadvantage is that the test may be slower and more resource consuming.
						</div>
						<div class="column">
							<br />
							or you can just inject the dependency yourself.
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									package com.motycka.edu.game.character

									import com.motycka.edu.game.account.AccountService
									import com.motycka.edu.game.character.model.CharacterLevel
									import com.motycka.edu.game.character.model.Warrior
									import io.mockk.every
									import io.mockk.mockk
									import io.mockk.verify
									import org.junit.jupiter.api.Assertions.assertEquals
									import org.junit.jupiter.api.Test

									class CharacterServiceTest {

										private val characterRepository: CharacterRepository = mockk()
										private val accountService: AccountService  = mockk()
										private val characterService: CharacterService = CharacterService(
											characterRepository = characterRepository,
											accountService = accountService
										)

										private val accountId = 1L

										@Test
										fun `createCharacter should return created character`() {
											val character = Warrior(
												id = 1,
												accountId = accountId,
												name = "Warrior",
												health = 140,
												attackPower = 20,
												experience = 0,
												stamina = 20,
												defensePower = 20,
												level = CharacterLevel.LEVEL_1
											)

											every { accountService.getCurrentAccountId() } returns accountId
											every { characterRepository.insertCharacters(accountId = accountId, character = character) } returns character

											val result = characterService.createCharacter(character)

											assertEquals(character, result)
											verify { characterRepository.insertCharacters(accountId = accountId, character = character) }
										}

									}
								</code>
							</pre>
							This test is going to be faster, but you are not testing the DI,
							which is not a big deal if you also have integration tests.
						</div>
					</div>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Project Work</h2>
			</section>
		</section>
	</div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
